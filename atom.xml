<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEBINGLIN</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://webinglin.github.io/"/>
  <updated>2017-05-25T15:47:25.605Z</updated>
  <id>http://webinglin.github.io/</id>
  
  <author>
    <name>weblinglin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字签名</title>
    <link href="http://webinglin.github.io/2017/05/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>http://webinglin.github.io/2017/05/24/数字签名/</id>
    <published>2017-05-24T13:26:46.000Z</published>
    <updated>2017-05-25T15:47:25.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>公钥加密算法又称为非对称加密算法，包含一个 公钥-私钥对，称为密钥对 key pair</p>
<p>公钥加密的只能私钥解密， 私钥加密的只能用公钥解密</p>
<p>常用的非对称加密算法有： RSA , DSA</p>
<h3 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h3><p>对任意长度的输入内容进行Hash运算，得到一个固定长度的数据。 输出数据称为消息摘要。（Digest）</p>
<p>常用的消息摘要算法（Hash算法）： MD5， SHA-1</p>
<a id="more"></a>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>用 私钥对信息摘要进行加密，就得到了数字签名。（Signature）</p>
<p>然后别人可以用 公钥 对数字签名进行解密，然后将内容进行同样的Hash运算，得到新的 信息摘要。对比新生成的信息摘要和收到的 数字签名解密出来的信息摘要。 就能判断 消息内容是否被修改过。</p>
<p>存在一个问题，我们无法确认 用来解密的公钥是否是合法的， 这时候需要 证书中心-CA（certificate authority）来为公钥认证。CA用自己的私钥，对我们发出的公钥和一些相关的信息一起加密，生成数字证书。（Digital Certificate）</p>
<p>这样，我们再用自己的私钥进行数字签名的时候，再带上该数字证书即可。 收件者收到信息之后，用CA的公钥解开数字证书，数字证书里面就可以得到我们自己的公钥，然后就能证明该数字签名就是我们的了。</p>
<h3 id="Https例子说明"><a href="#Https例子说明" class="headerlink" title="Https例子说明"></a>Https例子说明</h3><ol>
<li>客户端向服务器发出加密请求</li>
<li>服务器用自己的私钥对网页内容进行加密，然后连同本身的数字证书一起发给客户端。</li>
<li>客户端（浏览器）会根据 受信任的根证书颁发机构 列表来判断 解开数字证书的公钥是否在信任列表中。</li>
<li>如果数字证书记载的网址和我们正在浏览的网址不一致的话，就说明这张证书可能被盗用。浏览器会发出红色警告。</li>
<li>如果数字证书是可信任的，客户端就会使用证书中的公钥进行信息加密和服务器进行加密信息的交换。</li>
</ol>
<h3 id="keytool-命令的使用"><a href="#keytool-命令的使用" class="headerlink" title="keytool 命令的使用"></a>keytool 命令的使用</h3><h4 id="生成证书库"><a href="#生成证书库" class="headerlink" title="生成证书库"></a>生成证书库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -v -alias server -keyalg RSA -keysize 1024 -keypass yourKeyPWD -dname <span class="string">"cn=webinglin,ou=00,o=00,l=xm,st=fj,c=CN"</span> -keystore server.jks -storepass yourStorePWD -validity 3650</div></pre></td></tr></table></figure>
<h4 id="导出证书申请书"><a href="#导出证书申请书" class="headerlink" title="导出证书申请书"></a>导出证书申请书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -certreq -v -alias server -sigalg MD5withRSA -file server.csr -keypass yourKeyPWD -keystore server.jks -storepass yourStorePWD</div></pre></td></tr></table></figure>
<p><img src="https://github.com/webinglin/blogImages/blob/master/keytool/keytool.png?raw=true" alt="img"></p>
<p>// todo 将CSR提交给CA，再将CA的根证书，二级证书以及签发后的服务器证书一起导入keystore</p>
<h4 id="导入根证书"><a href="#导入根证书" class="headerlink" title="导入根证书"></a>导入根证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -import -alias root -trustcacerts -file root.cer -keystore server.jks -storepass yourStorePWD</div></pre></td></tr></table></figure>
<h4 id="导入-签名之后的-服务器证书"><a href="#导入-签名之后的-服务器证书" class="headerlink" title="导入 签名之后的 服务器证书"></a>导入 签名之后的 服务器证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -import -v -trustcacerts -keypass yourKeyPWD -alias server -file server.cer -keysotre server.jks -storepass yourStorePWD</div></pre></td></tr></table></figure>
<p>注意：这里的别名需要和证书库的别名保持一致，因为 server.cer 是由 server.jks 导出的证书申请书给CA签名之后的数字证书。</p>
<h4 id="将证书导出到证书文件"><a href="#将证书导出到证书文件" class="headerlink" title="将证书导出到证书文件"></a>将证书导出到证书文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -export -alias server -file server.cer -keystore server.jks</div></pre></td></tr></table></figure>
<p>将证书库 server.jks中别名为server的证书导出到server.cer证书文件中。证书文件包含了证书主题的信息以及证书的公钥，不包含私钥，是可以公开的。</p>
<h4 id="通过证书文件查看证书的信息"><a href="#通过证书文件查看证书的信息" class="headerlink" title="通过证书文件查看证书的信息"></a>通过证书文件查看证书的信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -printcert -file server.cer</div></pre></td></tr></table></figure>
<h4 id="显示指定别名的具体的证书"><a href="#显示指定别名的具体的证书" class="headerlink" title="显示指定别名的具体的证书"></a>显示指定别名的具体的证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -list -v -alias server -keystore server.jks</div></pre></td></tr></table></figure>
<h4 id="显示整个证书库里面的所有证书"><a href="#显示整个证书库里面的所有证书" class="headerlink" title="显示整个证书库里面的所有证书"></a>显示整个证书库里面的所有证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -list -keystore server.jks</div></pre></td></tr></table></figure>
<h4 id="删除密钥库中的条目"><a href="#删除密钥库中的条目" class="headerlink" title="删除密钥库中的条目"></a>删除密钥库中的条目</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -delete -alias server -keystore server.jks</div></pre></td></tr></table></figure>
<h4 id="修改密钥口令"><a href="#修改密钥口令" class="headerlink" title="修改密钥口令"></a>修改密钥口令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 证书条目口令修改</span></div><div class="line">keytool -keypasswd -alias server -keystore server.jks</div><div class="line"></div><div class="line"><span class="comment"># 证书条目口令的修改</span></div><div class="line">keytool -keypasswd -alias youAlias(需要修改密码的别名) -keypass origpwd(原始密码) -new newpwd(新密码) -keystore server.jks -storepass storepwd</div><div class="line"></div><div class="line"><span class="comment"># keystore口令修改</span></div><div class="line">keytool -storepasswd -keystore server.jks -storepass origPwd -new newPwd</div></pre></td></tr></table></figure>
<h4 id="查看证书信息"><a href="#查看证书信息" class="headerlink" title="查看证书信息"></a>查看证书信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -list -v -keystore youKS.jks -storepass yourStorePWD</div></pre></td></tr></table></figure>
<h3 id="客户端证书模拟"><a href="#客户端证书模拟" class="headerlink" title="客户端证书模拟"></a>客户端证书模拟</h3><p>我们可以模拟客户端数字证书，比如插入U-KEY的时候，会读取相应的数字证书和服务器进行通讯。如果我们没有U-KEY，那我们可以自己生成一个证书来模拟</p>
<h4 id="创建客户端密钥"><a href="#创建客户端密钥" class="headerlink" title="创建客户端密钥"></a>创建客户端密钥</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -v -alias clientKey -dname <span class="string">"CN=SomeOne"</span> -keyalg RSA -keypass 888888 -keystore client.p12 -storepass 888888 -storetype PKCS12</div></pre></td></tr></table></figure>
<h4 id="将客户端密钥导出为证书文件"><a href="#将客户端密钥导出为证书文件" class="headerlink" title="将客户端密钥导出为证书文件"></a>将客户端密钥导出为证书文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -export -alias clientKey -file client.cer -keystore client.p12 -storepass 888888 -storetype PKCS12</div></pre></td></tr></table></figure>
<h4 id="将上述的客户端证书导入到服务器证书库，设置为信任证书"><a href="#将上述的客户端证书导入到服务器证书库，设置为信任证书" class="headerlink" title="将上述的客户端证书导入到服务器证书库，设置为信任证书"></a>将上述的客户端证书导入到服务器证书库，设置为信任证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -import -v -alias clientKey -file client.cer -keystore server.jks -storepass 888888</div></pre></td></tr></table></figure>
<p>导入的时候选择 y 。允许导入即可</p>
<p>然后，我们可以通过安装client.p12来模拟证书验证</p>
<h3 id="签发Jar包"><a href="#签发Jar包" class="headerlink" title="签发Jar包"></a>签发Jar包</h3><p>对jar包的数字签名和认证过程和数字签名原理是一致的。jar包就是待发送的消息，经过签名之后，jar包内置了数字签名和公钥，验证就是对这两项数据进行验证。</p>
<p>当然加上CA的证书签发，那么这个jar包才能确保可信任。不然依旧会有警告jar包的发布者不受信任这样的情况。</p>
<p>经过签名之后，jar包内包含了如下内容：</p>
<ol>
<li>原jar包内编译过的class和resource文件</li>
<li>签名文件 META-INF/*.SF: 这是文本文件，包含了原jar包内的class和resource文件的Hash</li>
<li>META-INF/*.DSA：这是一个数据文件，包含了签名者的certificate和数字签名。其中certificate包含了签名者的有关信息和公钥，如果由CA签发，就是数字证书了（包含了签名者的基本信息和公钥）；数字签名是对 .SF文件内的Hash值使用私钥加密得到的。</li>
</ol>
<p>keytool支持的算法：</p>
<ol>
<li>RSA算法采用MD5进行Hash的</li>
<li>DSA采用 SHA-1进行Hash的。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># jarsigner读取keystore为jar包进行数字签名</span></div><div class="line">jarsigner -keystore yourKS.jks -signedjar tools_signed.jar tools.jar yourKS</div><div class="line"></div><div class="line"><span class="comment"># 验证</span></div><div class="line">jarsigner -verify tools_signed.jar</div></pre></td></tr></table></figure>
<h2 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h2><h4 id="server-xml配置"><a href="#server-xml配置" class="headerlink" title="server.xml配置"></a>server.xml配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"9443"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span> </span></div><div class="line">           <span class="attr">maxThreads</span>=<span class="string">"300"</span> <span class="attr">acceptCount</span>=<span class="string">"800"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span>   </div><div class="line">  <span class="attr">keystoreFile</span>=<span class="string">"store/server.ks"</span> <span class="attr">keystorePass</span>=<span class="string">"888888"</span></div><div class="line">  <span class="attr">truststoreFile</span>=<span class="string">"store/server.ks"</span> <span class="attr">truststorePass</span>=<span class="string">"888888"</span> </div><div class="line">           <span class="attr">clientAuth</span>=<span class="string">"true"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span> <span class="attr">sslEnabledProtocols</span>=<span class="string">"TLSv1.1"</span> /&gt;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>:  需要配置 sslEnabledProtocols=”TLSV1.1”  对于windowsXP的系统使用的是TLSv1.1的协议和服务器进行握手的，所以必须允许该协议。</p>
<h4 id="强制浏览器使用https协议访问-web-xml"><a href="#强制浏览器使用https协议访问-web-xml" class="headerlink" title="强制浏览器使用https协议访问(web.xml)"></a>强制浏览器使用https协议访问(web.xml)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">login-config</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">auth-method</span>&gt;</span>CLIENT-CERT<span class="tag">&lt;/<span class="name">auth-method</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">realm-name</span>&gt;</span>Client Cert Users-only Area<span class="tag">&lt;/<span class="name">realm-name</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">web-resource-collection</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">web-resource-name</span> &gt;</span>SSL<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">user-data-constraint</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">transport-guarantee</span>&gt;</span>CONFIDENTIAL<span class="tag">&lt;/<span class="name">transport-guarantee</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">user-data-constraint</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果在web.xml中加入这段配置，那么即使浏览器用 8080端口访问应用程序，也会自动切换成 8443端口来访问的。强制使用https协议。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://www.cnblogs.com/jackofhearts/p/jar_signing.html" target="_blank" rel="external">http://www.cnblogs.com/jackofhearts/p/jar_signing.html</a></p>
]]></content>
    
    <summary type="html">
    
      keytool命令详解以及数字签名，信息摘要等概念解释
    
    </summary>
    
    
      <category term="Java" scheme="http://webinglin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>引用awesome打造漂亮图标</title>
    <link href="http://webinglin.github.io/2017/05/16/%E5%BC%95%E7%94%A8awesome%E6%89%93%E9%80%A0%E6%BC%82%E4%BA%AE%E5%9B%BE%E6%A0%87/"/>
    <id>http://webinglin.github.io/2017/05/16/引用awesome打造漂亮图标/</id>
    <published>2017-05-16T12:50:08.000Z</published>
    <updated>2017-05-24T13:35:46.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ol>
<li>引用css文件 <link rel="stylesheet" href="${URL}/css/common/awesome/css/font-awesome.min.css"></li>
<li>将awesome文件引入工程路径，并修改font-awesome.min.css的字体文件路径。</li>
</ol>
<p>如果你也不想修改字体的路径，可以按照如下目录结构放置即可</p>
<p>-awesome</p>
<p>​    -css</p>
<p>​        font-awesome.min.css</p>
<p>​    -font</p>
<p>​        fontawesome-webfont.woff</p>
<p>​        … and so on</p>
</blockquote>
<p>用法讲解：</p>
<p>只需要将<code>&lt;i class=&quot;icon-search&quot;&gt;&lt;/i&gt;</code> 添加到想要设置图标的文字之前即可。加上空格会更美观</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button&gt;&lt;i class=&quot;icon-search&quot;&gt;&lt;/i&gt; 搜索&lt;/button&gt;</div></pre></td></tr></table></figure>
<p>icon-search 这样的图标样式awesome都已经帮我们定义好了，我们只需要引用即可。</p>
<p>下面用一幅图展示截取截止目前可用的图标样式:（来源官网）</p>
<a id="more"></a>
<p><img src="https://github.com/webinglin/blogImages/blob/master/awesome-icons.png?raw=true" alt=""></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://www.bootcss.com/p/font-awesome/" target="_blank" rel="external">font-awesome</a></p>
]]></content>
    
    <summary type="html">
    
      利用awesome的css图标库打造漂亮的web页面
    
    </summary>
    
    
      <category term="css" scheme="http://webinglin.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Java执行Python、Shell</title>
    <link href="http://webinglin.github.io/2017/05/04/Java%E6%89%A7%E8%A1%8CPython%E3%80%81Shell/"/>
    <id>http://webinglin.github.io/2017/05/04/Java执行Python、Shell/</id>
    <published>2017-05-04T13:42:02.000Z</published>
    <updated>2017-05-04T13:45:15.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>​    使用阿里的datax进行数据的同步，一开始用手动同步，在shell命令行执行python命令，没毛病。现在需要改成定时自动增量同步。所以使用Spring来实现定时任务的执行。这就涉及到使用JAVA来调用python脚本了，执行后，发现数据都没有同步成功。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>​    一开始用Process对象的getInputStream()获取输出结果，只有部分的输出结果，对比直接在shell命令行执行的输出结果还少了很多日志打印。</p>
<p>​    接着就怀疑是不是datax打印的日志太多了导致语句不能正常执行，于是就把logback.xml的stdout输出注释掉。问题依旧。</p>
<p>​    于是就在想怎么查看错误日志，看了datax的log目录底下的日志，没有错误信息。 通过 Process对象的 getErrorStream查看到了错误信息：     <code>/bin/sh/: java : command not found</code></p>
<a id="more"></a>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    报错的原因是java在执行python脚本的时候，默认是用系统的/bin/目录下的命令。 错误提示java命令找不到，那么就需要将java命令添加到/bin/目录底下，通过建立link来关联 java的命令</p>
<p><code>ln -s /usr/jdk1.7/bin java</code></p>
<p>再次通过java执行python脚本进行数据同步，同步成功。</p>
<h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Process process = Runtime.getRuntime().exec(cmds);</div><div class="line">process.waitFor();</div><div class="line"></div><div class="line"><span class="comment">// 打印正常的输出结果</span></div><div class="line">in = process.getInputStream();</div><div class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">logger.info(<span class="string">"执行命令结果:"</span>);</div><div class="line">String line ;</div><div class="line"><span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">	logger.info(<span class="string">"&#123;&#125;"</span>, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 打印错误的输出结果</span></div><div class="line">List&lt;String&gt; errorLines = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">errReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</div><div class="line"><span class="keyword">while</span>((line = errReader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">	errorLines.add(line);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(errorLines.size()&gt;<span class="number">0</span>) &#123;</div><div class="line">	logger.error(<span class="string">"执行命令出错信息:"</span>);</div><div class="line">	<span class="keyword">for</span>(String errorLine : errorLines)&#123;</div><div class="line">		logger.error(errorLine);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://webinglin.github.io/">webinglin.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      java执行Python或者Shell
    
    </summary>
    
    
      <category term="Java" scheme="http://webinglin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装后传</title>
    <link href="http://webinglin.github.io/2017/01/14/Ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E4%BC%A0/"/>
    <id>http://webinglin.github.io/2017/01/14/Ubuntu安装后传/</id>
    <published>2017-01-13T16:36:16.000Z</published>
    <updated>2017-05-04T13:02:05.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="替换阿里源"><a href="#替换阿里源" class="headerlink" title="替换阿里源"></a>替换阿里源</h2><ol>
<li><code>cd /etc/apt</code></li>
<li><code>sudo cp sources.list sources.list.bak</code></li>
<li><code>sudo vim sources.list</code></li>
<li>删除原来的源，替换成下面的三个源</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"># 阿里源</div><div class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</div><div class="line">deb http://archive.canonical.com/ubuntu xenial partner</div><div class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</div><div class="line"></div><div class="line"># 东北大学</div><div class="line">deb-src http://mirror.neu.edu.cn/ubuntu/ xenial main restricted #Added by software-properties</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial main restricted</div><div class="line">deb-src http://mirror.neu.edu.cn/ubuntu/ xenial restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-updates main restricted</div><div class="line">deb-src http://mirror.neu.edu.cn/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial universe</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-updates universe</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial multiverse</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-updates multiverse</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line">deb-src http://mirror.neu.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</div><div class="line">deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-security main restricted</div><div class="line">deb-src http://mirror.neu.edu.cn/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-security universe</div><div class="line">deb http://mirror.neu.edu.cn/ubuntu/ xenial-security multiverse</div><div class="line"></div><div class="line"># 清华大学</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</div><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</div></pre></td></tr></table></figure>
<ol>
<li><p>替换好源之后，执行<code>sudo apt-get update</code> 　更新</p>
<p>​<a id="more"></a></p>
</li>
</ol>
<h2 id="清理不常用软件"><a href="#清理不常用软件" class="headerlink" title="清理不常用软件"></a>清理不常用软件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove libreoffice-common	</div><div class="line">sudo apt-get remove unity-webapps-common </div><div class="line">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot </div><div class="line">sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install  </div><div class="line">sudo apt-get remove onboard deja-dup</div></pre></td></tr></table></figure>
<h2 id="更新Home目录中文名称为英文"><a href="#更新Home目录中文名称为英文" class="headerlink" title="更新Ｈome目录中文名称为英文"></a>更新Ｈome目录中文名称为英文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; export LANG=en_US</div><div class="line">&gt; xdg-user-dirs-gtk-update</div><div class="line">这时候会弹出界面，让我们选择是否更新名称，　选择是即可</div><div class="line">&gt; export LANG=zh_CN</div><div class="line">重启，会再次提示是否修改，　这时候，我们选择不修改，保留英文即可。　然后选择不再提示</div></pre></td></tr></table></figure>
<h2 id="禁用宾客会话"><a href="#禁用宾客会话" class="headerlink" title="禁用宾客会话"></a>禁用宾客会话</h2><p>如果没有lightdm.conf 那么就新建一个<br><code>sudo vim /etc/lightdm/lightdm.conf</code></p>
<p>接着将这段代码复制黏贴</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[SeatDefaults]</div><div class="line">greeter-session=unity-greeter</div><div class="line">allow-guest=false</div></pre></td></tr></table></figure>
<p>保存之后，重启一下lightdm　就不会有来宾账号了</p>
<p><code>service lightdm restart</code></p>
<h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><blockquote>
<p>常用软件安装到SSD, 像idea和jdk也都拷贝到SSD上</p>
</blockquote>
<h4 id="安装Typora"><a href="#安装Typora" class="headerlink" title="安装Typora"></a>安装Typora</h4><p>直接复制执行即可。如果安装没成功，重新执行一遍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># optional, but recommended</div><div class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</div><div class="line"># add Typora&apos;s repository</div><div class="line">sudo add-apt-repository &apos;deb https://typora.io ./linux/&apos;</div><div class="line">sudo apt-get update</div><div class="line"># install typora</div><div class="line">sudo apt-get install typora</div></pre></td></tr></table></figure>
<h4 id="安装网易云音乐"><a href="#安装网易云音乐" class="headerlink" title="安装网易云音乐"></a>安装网易云音乐</h4><ol>
<li><p>到官网下载 .deb软件包</p>
</li>
<li><p>重新配置依赖</p>
<p><code>sudo apt-get -f install</code></p>
</li>
<li><p><code>sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb</code></p>
</li>
</ol>
<p>安装之后就可以在 Dash中搜索到云音乐了，　或者执行<code>&gt; netease-cloud-music</code> 就可以启动网易云音乐了</p>
<h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>官网下载linux_jdk1.8_x64，　解压</p>
<p>配置环境变量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; sudo vim /etc/profile</div><div class="line"></div><div class="line"><span class="comment"># 将下面的环境变量设置拷贝到.profile文件的末尾</span></div><div class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.7.0_55   </div><div class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </div><div class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></div><div class="line"></div><div class="line"><span class="comment"># 执行source命令，让环境变量立刻生效</span></div><div class="line">&gt; <span class="built_in">source</span> /etc/profile</div><div class="line">&gt; java -version</div></pre></td></tr></table></figure>
<h4 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h4><p>官网下载IDEA　Linux版，执行　bin/idea.sh　即可启动 </p>
<p>IDEA2016 注册码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">43B4A73YYJ-eyJsaWNlbnNlSWQiOiI0M0I0QTczWVlKIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9XSwiaGFzaCI6IjMzOTgyOTkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-keaxIkRgXPKE4BR/ZTs7s7UkP92LBxRe57HvWamu1EHVXTcV1B4f/KNQIrpOpN6dgpjig5eMVMPmo7yMPl+bmwQ8pTZaCGFuLqCHD1ngo6ywHKIQy0nR249sAUVaCl2wGJwaO4JeOh1opUx8chzSBVRZBMz0/MGyygi7duYAff9JQqfH3p/BhDTNM8eKl6z5tnneZ8ZG5bG1XvqFTqWk4FhGsEWdK7B+He44hPjBxKQl2gmZAodb6g9YxfTHhVRKQY5hQ7KPXNvh3ikerHkoaL5apgsVBZJOTDE2KdYTnGLmqxghFx6L0ofqKI6hMr48ergMyflDk6wLNGWJvYHLWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</div></pre></td></tr></table></figure>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ol>
<li>nodejs官网下载最新的版本，解压，然后将bin目录添加到 /etc/profile　文件中</li>
<li>安装npm , <code>sudo apt-get install npm</code></li>
<li>npm升级到最新， <code>npm i -g npm@latest</code></li>
<li><code>npm install -g hexo-cli</code></li>
</ol>
<h2 id="替换hosts文件"><a href="#替换hosts文件" class="headerlink" title="替换hosts文件"></a>替换hosts文件</h2><p><a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="external">https://laod.cn/hosts/2017-google-hosts.html</a></p>
<p>(网盘备份)</p>
<h2 id="备份和还原Ubuntu"><a href="#备份和还原Ubuntu" class="headerlink" title="备份和还原Ubuntu"></a>备份和还原Ubuntu</h2><h4 id="备份系统"><a href="#备份系统" class="headerlink" title="备份系统"></a>备份系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># su root</div><div class="line"># tar cvpzf backup.tar.gz --exclude=/proc --exclude=/lost+found --exclude=/backup.tar.gz --exclude=/mnt --exclude=/sys --exclude=/media --exclude=/cdrom --exclude=/tmp  /</div></pre></td></tr></table></figure>
<blockquote>
<p>“tar”当然就是我们备份系统所使用的程序了。</p>
<p>“cvpfz”是tar的选项，意思是“创建档案文件”、“保持权限”(保留所有东西原来的权限)、“使用gzip来减小文件尺寸”。</p>
<p>“backup.tar.gz”是我们将要得到的档案文件的文件名。</p>
<p>“/”是我们要备份的目录，在这里是整个文件系统。</p>
<p>在 档案文件名“backup.gz”和要备份的目录名“/”之间给出了备份时必须排除在外的目录。有些目录是无用的，例如“/proc”、“/lost+ found”、“/sys”。当然，“backup.gz”这个档案文件本身必须排除在外，否则你可能会得到一些超出常理的结果。如果不把“/mnt”排 除在外，那么挂载在“/mnt”上的其它分区也会被备份。另外需要确认一下“/media”上没有挂载任何东西(例如光盘、移动硬盘)，如果有挂载东西， 必须把“/media”也排除在外。 </p>
</blockquote>
<h4 id="还原系统"><a href="#还原系统" class="headerlink" title="还原系统"></a>还原系统</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># su root</span></div><div class="line"><span class="comment"># tar xvpfz backup.tar.gz -C /	</span></div><div class="line"></div><div class="line"><span class="comment"># 恢复命令结束时，你的工作还没完成，别忘了重新创建那些在备份时被排除在外的目录：</span></div><div class="line"><span class="comment"># mkdir proc</span></div><div class="line"><span class="comment"># mkdir lost+found</span></div><div class="line"><span class="comment"># mkdir mnt</span></div><div class="line"><span class="comment"># mkdir sys</span></div><div class="line"><span class="comment"># mkdir media</span></div><div class="line"><span class="comment"># mkdir cdrom</span></div><div class="line"><span class="comment"># mkdir tmp</span></div></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://webinglin.github.io/">webinglin.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      ubuntu安装之后要处理的软件安装和备份
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://webinglin.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Spring cron 表达式</title>
    <link href="http://webinglin.github.io/2016/03/20/Spring-cron-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://webinglin.github.io/2016/03/20/Spring-cron-表达式/</id>
    <published>2016-03-20T03:07:59.000Z</published>
    <updated>2016-12-17T05:05:14.540Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cron 表达式的格式如下：</p>
<p><code>秒 分 时 日 月 星期</code></p>
<pre><code>秒： 0-59
分： 0-59
时： 0-23
日： 1-31
月： 1-12
星期：1-7 （1-星期天， 2-星期一，3-星期二，4-星期三 ... ...）
</code></pre><a id="more"></a>
<p>特殊字符:</p>
<pre><code>*  表示任意值，如果放在 小时域 ，表示的就是  每一小时

?  问号只能出现在星期或者日期 这两个域中，用于表示 不是明确的值。 月份中的日期和星期是两个相互排斥的元素，所以，通过问号来表明不指定其中某一个域。

/ 斜杠表示增量， 如 0/5 如果放在分钟，表示 从0分钟开始，每个5分钟执行过一次。  2/10 放在分钟域表示 从2分钟开始，每隔10分钟执行一次。

- 横杠表示范围， 如：  1-5 放在小时域，表示 每天的 1，2，3，4，5 这几个小时执行

, 指定范围， 如： 7,8,9 放在分钟域，表示：　７，８，９　分钟执行
</code></pre><p>例子：</p>
<pre><code>0 0 10 * * ?     每天10点 执行
0 5 10 * * ?     每天10点5分 执行
0 5 10 ? * *     每天10点5分 执行
0 5/10 5 * * ?  每天5点 5，15，25，35，45，55 这几个时间点 执行
0 10 10 ? * 2    每个月星期一，10点10分 执行    
0 10 10 ? * 1#3 每个月的第三个星期天 执行
</code></pre><p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      Spring cron 表达式
    
    </summary>
    
    
      <category term="Spring" scheme="http://webinglin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JQuery滚动加载</title>
    <link href="http://webinglin.github.io/2016/01/28/JQuery%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://webinglin.github.io/2016/01/28/JQuery滚动加载/</id>
    <published>2016-01-28T13:39:36.000Z</published>
    <updated>2016-12-17T17:48:42.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>场景：</p>
<p>在某系统遇到用户注册这样的功能，而注册需要将注册用户属于哪个单位也选上，以前做出的效果可能没那么理想（以前是用树形结构做的，每展开一级就加载下一级的数据。 因为数据量极大不可能一下子将所有的部门单位都加载出来）。 基于这种情况，我将其改成带搜索功能的输入选择框，并且输入某个关键字之后的弹窗里面的单位列表支持下拉滚动。同时也支持上一级单位和下一级单位的切换。 这样就解决了数据量太多导致树形控件难以使用的问题。 </p>
</blockquote>
<p>具体的下拉滚动代码大致如下：</p>
<a id="more"></a>
<pre><code>$(&quot;#deptBox&quot;).scroll(function(){
    var liHeight = $(&quot;#deptBox&quot;).scrollHeight; // 实际内容的高度 如每一个单位由一个 li 元素组成，那么当前页加载出来的 li 元素（如每页20条记录）就是内容的高度了。 理论值 大于等于容器高度
     var scrollHeight = $(&quot;#deptBox&quot;).scrollTop();// 页面内容往上滚出对话框的高度
    var dialogHeight = $(&quot;#deptBox&quot;).height(); // 容器的高度

    if((liHeight-scrollHeight-dialogHeight)/dialogHeight &lt; 0.02) { // (liHeight-scrollHeight-dialogHeight) 剩下的在对话框之外的还没看见页面内容 --对话框的下方，还没滚到可视区域

        // 继续加载
        var subDept = $(&quot;#deptBox&quot;).data(&quot;nodeList&quot;), index = $(&quot;#deptBox&quot;).data(&quot;index&quot;); // subDept 是当前级别的所有单位数据, index表示当前可视化区域已经遍历到第几条数据

        // 已经到底了，不继续加载
        if(subDept.length == index){
            $(&quot;#deptBox&quot;).append(&quot;&lt;li&gt; .. 已经到底了，不能继续滚动 .. &lt;/li&gt;&quot;);
            return false;                
        }

        var len = index + 20; // 每次下拉20条数据
        if(len&gt;subDept.length){
            len = subDept.length;
        }
        for(var i=index; i&lt;len; i++){
            createDeptElement(subDept[i]); // subDept是一个数组，数组的每一个元素表示一个部门单位的内容，包括部门名称，id，路径等信息    
            // createDeptElement 方法是将部门信息描绘成 li 元素，并且append到 deptBox 容器
        }    
        // 每次移动好了下标之后，将下标重新绑定到 deptBox 容器
        $(&quot;#deptBox&quot;).data(&quot;index&quot;,len);
    }
});
</code></pre><p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href=""></a></p>
]]></content>
    
    <summary type="html">
    
      Jquery滚动加载数据
    
    </summary>
    
    
      <category term="JQuery" scheme="http://webinglin.github.io/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>window.open 窗口存在继续打开</title>
    <link href="http://webinglin.github.io/2016/01/28/window-open-%E7%AA%97%E5%8F%A3%E5%AD%98%E5%9C%A8%E7%BB%A7%E7%BB%AD%E6%89%93%E5%BC%80/"/>
    <id>http://webinglin.github.io/2016/01/28/window-open-窗口存在继续打开/</id>
    <published>2016-01-28T13:38:44.000Z</published>
    <updated>2016-12-17T17:49:49.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>场景： </p>
<p>用JQuery模拟出类似window桌面, 当点击模拟出来的桌面上的某一个菜单图标的时候，要在浏览器上打开一个新的标签页，代表打开的那个模块， 如果再次点击刚才那个菜单，不能再另开一个标签页，而是让第一次打开的标签页获得焦点。</p>
<p>于是，就有了下面这段代码, 代码不能直接复用，根据自己需要小小修改一下即可。</p>
</blockquote>
<pre><code>-- 其中 win 是全局变量， id 和 url 都是动态的，每一个菜单都有自己的一套配置，basePath 指向web应用的根路径,如： http://127.0.0.1:8080/yourweb/

win = window.open(&quot;&quot;,id+&quot;_window&quot;); 
if(win.location.href===&quot;about:blank&quot;){
    // 窗口不存在
    win = window.open(basePath + url, id+&quot;_window&quot;);
} else {
    window.focus();
    // 如果要刷新 --&gt; win.location.href = basePath + url ;
}
</code></pre><p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      javascript打开之前存在的窗口
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://webinglin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 分区</title>
    <link href="http://webinglin.github.io/2016/01/28/MySQL-%E5%88%86%E5%8C%BA/"/>
    <id>http://webinglin.github.io/2016/01/28/MySQL-分区/</id>
    <published>2016-01-28T11:22:37.000Z</published>
    <updated>2016-12-17T17:50:44.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h2><p>在mysql中如果数据量太大了，除了分表还可以分区。对于单个表进行分区。分区分为横向分区和纵向分区。</p>
<ul>
<li>横向分区： 切分行，将某一些行分到某一个分区中。</li>
<li>纵向分区： 切分列，将某一些列分到某一个分区。</li>
</ul>
<p>目前我实践过的是横向分区。</p>
<p>可以通过下面命令来判断当前的mysql版本支不支持分区</p>
<p><code>mysql&gt; show variables like &quot;%part%&quot;;</code></p>
<p>如果支持的话，变量的值是 YES</p>
<p>分区的方式有好几种，分别是：</p>
<a id="more"></a>
<ul>
<li>Range分区</li>
<li><p>按照Range分区的话会将数据划分成一个给定的连续区间的行。</p>
<pre><code>-- 创建Range分区
CREATE TABLE RES_X (
    partionKey int(2) not null,
    val int(10)     
) engine=MyISAM default CHARTSET=utf8 
partition by RANGE(partionKey) (
    partition p0 values less than (1),
    partition p1 values less then (2),
    partition p1 values less then (3),
    partition p1 values less then (4),
    partition p1 values less then (5)
) ;
</code></pre></li>
</ul>
<pre><code>-- 查看表是否使用了分区
show table status;

-- 查看表具有几个分区，分区的方式，每个分区中的记录数
select * from information_schema.PARTITIONS WHERE TABLE_SCHEMA=schema() and table_name=&apos;RES_X&apos;

-- 查看某查询语句从那个分区中查的数据，可以通过 EXPLAIN 命令
EXPLAIN PARTITIONS ( SELECT * FROM RES_X WHERE partionKey = xx)
</code></pre><ul>
<li><p>list分区</p>
<pre><code>- 创建 List 分区
CREATE TABLE RES_X (
    partionKey int(2) not null,
    val int(10)     
) engine=MyISAM default CHARTSET=utf8 
partition by LIST(partionKey) (
    partition p0 values in (1,2,3,4),
    partition p1 values in (5,6,7),
    partition p1 values in (8,9),
    partition p1 values in (10,11,12,13),
    partition p1 values in (14,15)
) ;
</code></pre></li>
<li><p>hash分区</p>
</li>
</ul>
<pre><code>-- 创建Hash分区
CREATE TABLE RES_X (
    partionKey int(2) not null,
    val int(10)     
) engine=MyISAM default CHARTSET=utf8 
partition by HASH(partionKey) 
partitions 4 ;
</code></pre><ul>
<li>key分区</li>
</ul>
<pre><code>-- 创建KEY分区
CREATE TABLE RES_X (
    partionKey int(2) not null,
    val int(10)     
) engine=MyISAM default CHARTSET=utf8 
partition by KEY(partionKey) 
partitions 4 ;
</code></pre><p>在实践中使用的是第一种Range分区方式。后面三种分区方式应该也是大同小异，差不了太多。</p>
<p>在上面创建分区的时候，都指定了表的引擎使用 MyISAM , 那么mysql有哪些引擎，以及各种存储引擎的区别又是什么？</p>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>在mysql客户端，通过命令：</p>
<pre><code>mysql&gt; show engines;
</code></pre><p>就可以看到Mysql支持的存储引擎</p>
<h4 id="MyISAM-使用场景"><a href="#MyISAM-使用场景" class="headerlink" title="MyISAM 使用场景"></a>MyISAM 使用场景</h4><p>MyISAM表无法处理事务，所以，如果有事务要求的表不能使用MyISAM引擎。</p>
<ol>
<li>MyISAM存储引擎在筛选大量数据是非常迅速。</li>
</ol>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是一个健壮的事务型存储引擎。</p>
<ol>
<li>要求支持事务的表</li>
<li>支持自增属性 auto_increment</li>
<li>更新密集的表。</li>
<li>外键约束</li>
</ol>
<p>目前在应用中也就用了这两种类型的存储引擎。还有几种存储引擎<br>如： MEMORY , MERGE, ARCHIVE。</p>
<p>通常基本上都用 InnoDB 存储引擎。默认也是这个。 当然，如果遇到数据量很大，基本上只用于查询作用，比如作为某种类型的资源库。 那么可以改用 MyISAM 存储引擎。</p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      mysql,mysql分区，mysql存储引擎
    
    </summary>
    
    
      <category term="MySQL" scheme="http://webinglin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查询性能优化</title>
    <link href="http://webinglin.github.io/2015/12/11/Mysql-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://webinglin.github.io/2015/12/11/Mysql-查询性能优化/</id>
    <published>2015-12-11T13:26:08.000Z</published>
    <updated>2016-12-17T17:50:49.672Z</updated>
    
    <content type="html"><![CDATA[<p>先前写过一篇关于Mysql入库性能调优的文章，既然入库了，数据必然是要使用的，查询并以某种可视化的方式展现数据是很常见的使用方式。（如：D3.JS，Echarts，Highchart, i2 或是 其他的可视化工具）。</p>
<p>寒天一滴水，点点在心头。这里记录下Mysql优化的一些学习笔记。</p>
<ul>
<li>对于查询的优化，首先应该避免全表扫描，所以在where 及 order by涉及到的列上建索引。</li>
</ul>
<a id="more"></a>
<ul>
<li><p>避免使用null值的判断，否则会导致全表扫描。应该在入库的时候设置正确的数据类型，以及默认值。 比如 <code>where col=0 ;</code> 而不应该用 <code>where col is null;</code></p>
</li>
<li><p>如果可以，避免使用范围查询，如： !=, &gt; ,&lt; , in , not in , between 等操作符，这些会导致查询不走索引，造成全表扫描。</p>
</li>
<li><p>由于Mysql索引符合最左匹配原则，所以 like ‘%str%’ 是不会走索引的。 而 like ‘str%’ 这个确实会走索引的。所以，尽量不要再mysql中做全文检索的操作，这种工作可以用solr，elasticsearch 这种搜索引擎来处理。</p>
</li>
<li><p>避免在 where 子句中对字段进行函数操作，这会导致放弃索引而造成全表扫描。</p>
</li>
<li><p>对于 in 的操作可以考虑使用 join…on 来关联查询</p>
</li>
<li><p>group by col 默认的情况下，group by 会对col进行排序，这就是为什么在使用 explain的时候 在extr这列会有 filesort 。 所以，如果仅仅只需要分组，而不需要排序的话，在 group by 后面加上 order by null ( 如: <code>select username , count(1) as cnt from user group by username order by null ;</code>) 。这样会快很多。因为少了filesort。 filesort是很慢的。</p>
</li>
<li><p>整数类型查询不使用引号 。 字符串查询加上引号，否则不会使用索引。 对于字符串的查询不合理的做法：<code>select xx from tb where str=111;</code> ； 合理的查询语句应该是： <code>select xx from tb where str=&#39;111&#39;</code></p>
</li>
<li><p>对于select语句，尽量是需要什么就查什么，不要一下子就习惯性的使用 <code>select * from t;</code>， 而应该只把你想要的查出来就好了。 <code>select name from t ;</code> ； 我个人还有一个习惯，在对一张未知的表进行查询之前，习惯性的会先查总数 <code>select count(1) from t;</code> ，如果总数不是太大，就可以直接查所有了。 不然就使用limit限制一下查询条数。</p>
</li>
<li><p>说到limit，也有一点值得说的，比如你知道某一个查询结果只会有一条记录，那么可以在查询语句上限制 <code>limit 1;</code> 。 比如在有几条记录，我们想要根据时间，取到最近的一条记录。如果不适用limit的话，我们可能会这样查:<code>select xtime from t where xtime=(select max(xtime) from t) ;</code> 。 所以，用limit的话就变成 <code>select xtime from t order by xtime limit 1 ;</code> 。响应文章开头所属的，对于order by 的列记得建个索引。建索引语法:<code>create index your_idx on tablename(colNmae) l</code></p>
</li>
</ul>
<p>总结： 多用 <strong>EXPLAIN</strong> 分析查询语句</p>
<h3 id="附-查询缓存相关的命令"><a href="#附-查询缓存相关的命令" class="headerlink" title="(附)查询缓存相关的命令"></a>(附)查询缓存相关的命令</h3><pre><code>-- 设置查询缓存:

-- 查询缓存是否开启， on:表示开启， off:表示关闭
&gt; select @@query_cache_type;
&gt; set session query_cache_type=off;
&gt; set session query_cache_type=on;

-- 查询缓存的大小:
&gt; select @@global.query_cache_size;
&gt; set @@global.query_cache_size=1000000;

-- 查询缓存的上限:
&gt; select @@global.query_cache_limit;
&gt; set @@global.query_cache_limit=5000000;
</code></pre><p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://webinglin.github.io">http://webinglin.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      msyqls 性能优化
    
    </summary>
    
    
      <category term="MySQL" scheme="http://webinglin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 入库性能优化</title>
    <link href="http://webinglin.github.io/2015/12/01/Mysql-%E5%85%A5%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://webinglin.github.io/2015/12/01/Mysql-入库性能优化/</id>
    <published>2015-12-01T13:24:09.000Z</published>
    <updated>2016-12-17T17:50:35.979Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发一个数据量比较大的模块，此模块涉及到要把数据存入中间表，因为数据量太大了，无法一次性的加载到内存中分析。关键是分析的结果还要进行分页，排序，因此保存在中间表方便后续操作。曾想把中间结果存到<em>MongoDB</em>，但是数据量太大了，内存耗不起，况且<em>MongoDB</em> 比较适合存放那些原原本本的数据，查询过程中要尽量避免计算，统计等。 在我们现有的架构中，还有<em>Solr</em>和<em>Mysql</em>，但是由于<em>Solr</em>比较适合做全文检索，不适合当成数据库使用（一旦SolrQuery复杂一点，感觉Solr的查询速度相比建了索引的Mysql也是较慢的）,况且 <em>MongoDB</em> 和 <em>Solr</em>也不适合做一些复杂的统计。最终选择了<em>Mysql</em>作为存放中间数据的数据库。</p>
<p>我们当前的架构包含了Hibernate，如果使用Hibernate的批量插入那肯定不行啦，所以，首先想到的是最原始的jdbc的批量操作。</p>
<a id="more"></a>
<p><strong>附 Hibernate批量操作：</strong></p>
<pre><code>Session session = getCurrentSession();
for(int i=0,size=datas.size(); i&lt;size; i++){
    session.save(datas.get(i));
    if(i%50 == 0){
        session.flush();
        session.clear();
    }
}
session.flush();
session.clear();
</code></pre><p><strong>原生的JDBC批量插入</strong></p>
<pre><code>getCurrentSession().doWork(new Work(){
    @Override
    public void execute(Connection conn) throws SQLException {
        conn.setAutoCommit(false);
        PreparedStatement pstmt = conn.prepareStatement(insetSQL);
        try {
            for(int i=0,size=datas.size(); i&lt;size; i++){
                pstmt.setString(1,&quot;yourString&quot;);
                pstmt.setString(2,&quot;yourString&quot;);
                pstmt.setString(3,&quot;yourString&quot;);

                pstmt.addBatch();
                if(i%50){
                    pstmt.executeBatch();
                    conn.commit();
                }
            }
            pstmt.executeBatch();
            conn.commit();
        } catch(Exception e){
            logger.error(&quot;&quot;,e);
        } finally{
            if(pstmt!=null){
                pstmt.close();
                pstmt = null;
            }
        }
    }

});
</code></pre><p>经过测试，原生的JDBC的批量插入方式也是很慢的，2000条每秒的速度。 如果对于一千万的数据，那得等到猴年马月。</p>
<p>为了减少mysql的日志写，以及这样一条一条的插入。查找资料发现，如果将整个文件直接导入给mysql的话速度会快非常多。于是，就开始测试啦。</p>
<p>先测试将数据写到临时文件，这个写入到临时文件，直接用apache的commons-io就可以啦。直接将一个List当成一个集合，使用 FileUtils.writeLines() 方法即可。速度也是比较可观的，在自己电脑上（4G,酷睿i3）可以达到 11万/每秒。</p>
<p>接着测试将整个文件导入到数据库中，测试的结果是 5.X万/每秒。 这样的话基本上入库的话每秒可以<br>3.x万/每秒</p>
<pre><code>load data LOCAL infile &apos;$fileName&apos; into table $tableName
fields TERMINATED by &apos;,&apos;
lines TERMINATED by &apos;\r\n&apos;;
</code></pre><p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      mysql 入库性能优化
    
    </summary>
    
    
      <category term="MySQL" scheme="http://webinglin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spark Tutorials 01 : Introduce To Spark</title>
    <link href="http://webinglin.github.io/2015/11/07/Spark-Tutorials-01-Introduce-To-Spark/"/>
    <id>http://webinglin.github.io/2015/11/07/Spark-Tutorials-01-Introduce-To-Spark/</id>
    <published>2015-11-07T10:10:33.000Z</published>
    <updated>2016-12-17T17:50:28.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Spark 是一个用来实现 快速而通用 的集群计算平台。</p>
</blockquote>
<p>Spark由许多组件组成，包括：</p>
<ol>
<li>Spark Core ： Spark Core 实现了Spark的基本功能，包含任务调度，内存管理，错误恢复，与存储系统交互等模块。Spark Core 还包含了对RDD的API定义。</li>
<li>Spark SQL ： Spark SQL 是spark用来操作结构化数据的程序包。</li>
<li>Spark Streaming ： Spark Streaming 是Spark提供的对实时数据进行流式计算的组件。</li>
<li>MLib ： 机器学习功能的程序库</li>
<li>GraphX ： 用来操作图的程序库(比如社交网络的朋友关系图）</li>
</ol>
<p><img src="http://m1.yea.im/3Nl.png" alt=""></p>
<a id="more"></a>
<h2 id="Spark初始使用"><a href="#Spark初始使用" class="headerlink" title="Spark初始使用"></a>Spark初始使用</h2><p>例子中使用的是：</p>
<ol>
<li>JDK 1.7</li>
<li>spark-1.4.1-bin-hadoop2.6</li>
<li>虚拟机</li>
</ol>
<p>下载sparke之后，上传到虚拟机上面自己指定的目录下。<br>运行 <code>tar -zxvf spark-1.4.1-bin-hadoop2.6.tgz</code> 解压。</p>
<p>解压之后目录结构大致如下<br><img src="http://m1.yea.im/3No.png" alt=""></p>
<p>我们进入到Spark根目录。 并运行 bin/spark-shell<br><code>&gt;bin/spark-shell</code></p>
<p>启动的界面大致如下图所示:<br><img src="http://m1.yea.im/3Nr.png" alt=""></p>
<p>如果你启动的界面有很多Info的信息，那么进入到conf目录下面，编辑log4j.properties，将日志级别从INFO调成 WARN 级别。</p>
<p>至此，Spark最简单的单击环境就搭建完成了。</p>
<h2 id="Spark的Hello-World"><a href="#Spark的Hello-World" class="headerlink" title="Spark的Hello World"></a>Spark的Hello World</h2><p>学习一门语言最开始都是学习HelloWorld。 那在大数据方面，学习的第一个例子则是计算单词个数。</p>
<p><img src="http://m1.yea.im/3Ns.png" alt=""></p>
<p>现在不用明白什么是flatMap， 什么是 map。 因为这些只是Spark的一些方法而已。</p>
<p>例子中最后求得的 counts 也是 RDD， 是一个表明 README.md 这个文件中包含的单词个数的RDD。<br>我们可以通过<code>scala&gt; counts.count()</code> 这个方法将单词个数求出。</p>
<h3 id="RDD是什么？"><a href="#RDD是什么？" class="headerlink" title="RDD是什么？"></a>RDD是什么？</h3><p>RDD 是Spark的核心数据抽象，Resilient Distribute Dataset （弹性分布式数据集）。</p>
<p>RDD 有两种操作，一种是转换（transformation），一种是行动（action）。 所谓的转换是将一个RDD通过一定的操作之后，返回另一个全新的RDD,而原来的RDD还保留在内存中，方便后续使用。例如上述例子中： map， flatMap 等</p>
<p>所谓的行动则是执行实际的计算，它们会将计算所得的结果返回给驱动器程序。如上述例子中的 count。 会将RDD中包含的总数返回给spark shell。</p>
<p>需要注意的是, RDD的转换操作是惰性求值的。惰性求值意味着当我们对RDD调用转换操作（如：map）的时候，操作不会立刻执行。同样，把数据读取到RDD的操作也是惰性的，因此，当我们调用 sc.textFile(..) 的时候，数据并没有读取进来，而是在必要的时候才会读取。 而这个必要的时候就是行动执行的时候。如： 调用 RDD的 count()方法之后，就会强制Spark执行RDD 的转换操作。</p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p>《OReilly.Learning.Spark.Lightning-Fast.Big.Data.Analysis》</p>
]]></content>
    
    <summary type="html">
    
      spark tutorials
    
    </summary>
    
    
      <category term="Spark" scheme="http://webinglin.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 接收数组参数</title>
    <link href="http://webinglin.github.io/2015/11/01/SpringMVC-%E6%8E%A5%E6%94%B6%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0/"/>
    <id>http://webinglin.github.io/2015/11/01/SpringMVC-接收数组参数/</id>
    <published>2015-11-01T04:54:08.000Z</published>
    <updated>2016-12-17T17:50:18.061Z</updated>
    
    <content type="html"><![CDATA[<p>如果 JQuery 要往服务端传递一个数组参数，请求的方式如下</p>
<pre><code>$.ajax({
    url : ${yourURL},
    data: {yourParam:[1,2,3,4]},
    success:function(data){
    }
});
</code></pre><p>或者：</p>
<pre><code>$.ajax({
    url : ${yourURL},
    data: {&quot;yourParam[]&quot;:[1,2,3,4]},
    success:function(data){
    }
});
</code></pre><p>前端传递参数这两种写法都可以，建议写成第二种，而服务端的接收参数对应起来。</p>
<p>那么在服务端的 Controller怎么接收这个参数？</p>
<pre><code>@RequestMapping（&quot;/save&quot;)
public void save(@RequestParam(value=&quot;yourParam[]&quot; String[] yourParam){
    // do Something...
}
</code></pre><p>注意： @RequestParam 一定要用数组的形式 “yourParam[]” 作为接收参数， 这样的话才能够正确的接收到前端传递的数组， 如果前端的数组为空，接收到的也是空串。  比如：前端传递的参数： <code>data:{&quot;yourParam[]&quot;:[null,null,null]}</code> 那么服务端接收到的参数将会是 [“”,””,””] 无需担心空指针问题。</p>
<p>如果不用 “yourParam[]” 作为接收参数的话，将会发生莫名的错误。</p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      ajax如何传数组到后台
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://webinglin.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA14 起步</title>
    <link href="http://webinglin.github.io/2015/07/02/IntelliJ-IDEA14-%E8%B5%B7%E6%AD%A5/"/>
    <id>http://webinglin.github.io/2015/07/02/IntelliJ-IDEA14-起步/</id>
    <published>2015-07-02T12:12:07.000Z</published>
    <updated>2016-12-17T17:48:55.576Z</updated>
    
    <content type="html"><![CDATA[<p>Myeclipse确实功能很强大，我也一直在用Myeclipse。但是Myeclipse确实太庞大了，有的没的一大堆。听闻IntelliJ IDEA非常好用，一年前就用了两个月。工作原因又回归到Myeclipse。这次再次使用IDEA的时候发现很多东西都陌生了。甚至一些IDEA基本的概念都忘却了。</p>
<a id="more"></a>
<h3 id="IDEA和Eclipse的一些区别"><a href="#IDEA和Eclipse的一些区别" class="headerlink" title="IDEA和Eclipse的一些区别"></a>IDEA和Eclipse的一些区别</h3><p>IDEA 的Project 对应 Eclipse 的workspace</p>
<p>IDEA 的Module 对应 Eclipse 的Project</p>
<p>IDEA中一个Project可以有多个Module</p>
<p>Eclipse中一个Workspace可以包含多个Project</p>
<h3 id="Facets-和-artifacts-的区别"><a href="#Facets-和-artifacts-的区别" class="headerlink" title="Facets 和 artifacts 的区别"></a>Facets 和 artifacts 的区别</h3><p>Facets 表示这个module有什么特征，比如 web，spring，hibernate等</p>
<p>Artifact 是mvaen的一个概念，表示某个module要如何打包，例如：war explored、war、jar、ear等等打包方式 </p>
<p>一个module有了 Artifacts 就可以部署到应用服务器中了。</p>
<blockquote>
<p>Artifact可以理解为软件开发过程中的某一个阶段的产物,工件</p>
</blockquote>
<p><strong>在给项目配置Artifacts的时候有好多type选项，exploed是什么意思?</strong></p>
<p>explode在这里表示展开，不压缩的意思。也就是war，jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改文件的效果立刻显现出来。</p>
<p>默认情况下，IDEA的Modules和Artifacts的output目录已经设定好了，不需要改动。打包成war包的时候会自动在WEB-INF下产生classes目录。然后把编译后的文件放进去。</p>
<h3 id="IDEA和Tomcat"><a href="#IDEA和Tomcat" class="headerlink" title="IDEA和Tomcat"></a>IDEA和Tomcat</h3><ol>
<li><p>配置Tomcat， 通过 File-&gt; settings 找到Application Servers的配置，点击绿色按钮添加自己的tomcat版本<br><img src="http://i3.tietuku.com/38dbfcc8f479ee4b.jpg" alt=""></p>
</li>
<li><p>查看我们的web项目，看是否有web特性， 通过右键-&gt;Open Module Setting 或者使用快捷键 F4来打开我们的模块设置<br><img src="http://i3.tietuku.com/b123f540523c5d38.jpg" alt=""></p>
</li>
</ol>
<p>根据上文提到的一些概念我们已经明白了，要部署web应用，需要给我们的模块添加Web特性。<br>所以添加了web特性的模块我们就可以用来部署了。</p>
<p>为我们的模块添加添加web特性的时候，可以让IDEA帮我们生成web.xml，我们需要将web.xml修改成我们自己的目录结构位置。<br><img src="http://i3.tietuku.com/a4eab4a02cbb29eb.jpg" alt=""></p>
<p>同时需要指定web应用默认的根目录。我们依旧指定（修改） 为我们自己的目录结构中的web应用根目录（Gradle，Maven中使用 src/main/webapp)<br><img src="http://i3.tietuku.com/005a51f86c1211cc.jpg" alt=""></p>
<p>部署web应用到tomcat中，需要在Edit Configuration配置我们的tomcat，如果配置处没有找到tomcat servers，那么就是我们在清理IDEA插件的时候把Tomcat插件清楚了，去pluigns配置项里面启用即可。<br><img src="http://i3.tietuku.com/009a1b40b15a3f6b.jpg" alt=""></p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://blog.csdn.net/likaihon/article/details/44174553" target="_blank" rel="external">http://blog.csdn.net/likaihon/article/details/44174553</a></p>
]]></content>
    
    <summary type="html">
    
      首次使用IntelliJ IDEA14
    
    </summary>
    
    
      <category term="Idea" scheme="http://webinglin.github.io/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>MyEclipse常见问题与性能优化</title>
    <link href="http://webinglin.github.io/2015/06/25/MyEclipse%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://webinglin.github.io/2015/06/25/MyEclipse常见问题与性能优化/</id>
    <published>2015-06-25T11:22:54.000Z</published>
    <updated>2016-12-17T17:51:02.771Z</updated>
    
    <content type="html"><![CDATA[<p>Myeclipse是一个非常好用的IDE（集成开发环境），使用很简单，但是要驾驭它却要一个长期的使用和总结经验，之所以写这篇文章是因为今天早上我的myeclipse总是自动退出，试过很多办法都没法解决，后来我的同事（肖帅哥）问我myeclipse有没有优化，我说，是指调整内存吗？ 接着他就过来教了我几招。因此就写下此文来记录今天所学以及之前使用过程中的一些经验教训</p>
<a id="more"></a>
<p>平时在使用myeclipse的时候并没有过多的在意所谓的性能，基本上我的myeclipse启动起来，快捷键也基本都是用默认的，一些基本的配置会用（比如配置插件，tomcat，字体，jdk，maven等等）。其他也没有过多的考虑。很惭愧，用了myeclipse这么久，只知道启动的时候会很慢，也没想过要去对这个启动过程调优。</p>
<h3 id="调整myeclipse的使用内存"><a href="#调整myeclipse的使用内存" class="headerlink" title="调整myeclipse的使用内存"></a>调整myeclipse的使用内存</h3><p>找到myeclipse的安装目录，在根目录下面有一个myeclipse.ini文件，打开并编辑</p>
<pre><code>-vmargs
-Xmx512m
-XX:PermSize=256m
-XX:MaxPermSize=256m
-XX:ReservedCodeCacheSize=64m
</code></pre><p>其中 -Xmx512m 表示给堆内存区分配最大内存512MB，而PermSize表示的是class文件存放的内存，经常出现的Perngen outof memory，类似这样的问题，解决方法之一就是调整这个内存。（导致的原因有很多，在tomcat的官网有一些关于<permgenexception> –异常名称大致是这样 的介绍）</permgenexception></p>
<p>###优化myeclipse的启动加载项<br>打开myeclipse 找到  Window –&gt; Perferences  搜索 startup<br><img src="http://i1.tietuku.com/4b309ecd27d6c494.jpg" alt=""></p>
<p>把自己不需要的组件全部都去勾选，这样子的话启动myeclipse会快很多。勾选完之后，点击OK 重启myeclipse即可看到效果。</p>
<h3 id="显示对内存使用状态"><a href="#显示对内存使用状态" class="headerlink" title="显示对内存使用状态"></a>显示对内存使用状态</h3><p><img src="http://i1.tietuku.com/22c7f52014369a20.jpg" alt=""></p>
<p>设置好之后，就可以在myeclipse的右下角看到堆内存使用状态了</p>
<p><img src="http://i1.tietuku.com/e07f37dd51d4f4c9.jpg" alt=""></p>
<h3 id="去掉所有的验证"><a href="#去掉所有的验证" class="headerlink" title="去掉所有的验证"></a>去掉所有的验证</h3><p>myeclipse会自己帮我们验证很多东西，js，jsp等。 这样会导致我们编译什么的都非常慢,所以我习惯性的将所有的自动验证都去掉，所有的验证都自己来。<br><img src="http://i1.tietuku.com/052e58c7bbf93241.jpg" alt=""></p>
<h3 id="Clean技巧"><a href="#Clean技巧" class="headerlink" title="Clean技巧"></a>Clean技巧</h3><p>经常将应用部署到tomcat的时候，由于缓存的原因，自动化编译的时候不能将重新编译的class文件热部署到tomcat中。然后我们就会一直沉浸在旧代码中调试，一直疑问为什么修改了还没有效果的时候。clean或许是一种很有效的方法</p>
<p><img src="http://i1.tietuku.com/01754870b3c4a9a4.jpg" alt=""></p>
<p>因为工作空间的项目我都关闭了，所以 Clean…是灰色的</p>
<h3 id="Myeclipse自动退出问题"><a href="#Myeclipse自动退出问题" class="headerlink" title="Myeclipse自动退出问题"></a>Myeclipse自动退出问题</h3><p>我遇到最尴尬的问题就是自动退出了，当我们写着代码的时候，突然输入点号（比如 a.b ) 当输入b就自动退出了，然后 点号不用输入的，而是从其他文本编辑器写好，然后复制进来，这样竟然就不会退出。非常纠结，一开始就以为内存问题，因为退出的时候会提示内存的配置信息。所以就自以为是的调整内存大小。调整来调整去也不见得啥效果，期间也试过网上说的很多办法。后来我的一个同事（蔡帅哥）说切换一下工作空间试试。这句话点醒了我，于是乎我就<strong>把workspace的metadata文件给删了，然后重启myeclipse让其重新生成metadata文件夹</strong>，这样问题就解决了。</p>
<blockquote>
<p><strong>如果您有更多关于myeclipse的使用技巧，或者说优化技巧，欢迎留言和我们分享~~</strong></p>
<p>如果本文有不足之处，欢迎指正~~</p>
</blockquote>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3>]]></content>
    
    <summary type="html">
    
      MyEclipse常见问题与性能优化
    
    </summary>
    
    
      <category term="Eclipse" scheme="http://webinglin.github.io/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>JQuery事件 document绑定 VS ID绑定</title>
    <link href="http://webinglin.github.io/2015/06/24/JQuery%E4%BA%8B%E4%BB%B6-document%E7%BB%91%E5%AE%9A-VS-ID%E7%BB%91%E5%AE%9A/"/>
    <id>http://webinglin.github.io/2015/06/24/JQuery事件-document绑定-VS-ID绑定/</id>
    <published>2015-06-24T12:42:38.000Z</published>
    <updated>2016-12-17T17:57:05.594Z</updated>
    
    <content type="html"><![CDATA[<h4 id="document-on-39-click-39-39-id-39-function-和-39-id-39-on-39-click-39-function-到底有什么区别？"><a href="#document-on-39-click-39-39-id-39-function-和-39-id-39-on-39-click-39-function-到底有什么区别？" class="headerlink" title="$(document).on(&#39;click&#39;,&#39;#id&#39;,function(){}) 和 $(&#39;#id&#39;).on(&#39;click&#39;,function(){}) 到底有什么区别？"></a><code>$(document).on(&#39;click&#39;,&#39;#id&#39;,function(){}) 和 $(&#39;#id&#39;).on(&#39;click&#39;,function(){})</code> 到底有什么区别？</h4><p>这个问题在stackoverflow上面已经讨论过了，我今天也遇到这个问题。但是我在遇到该问题的时候想到的不是第一种做法，而是采用第二种在改版。后来我的同事小丸子这样写事件监听，我觉得很神奇，我就去google了。看到stackoverflow的这个答案我就明朗了。感谢小丸子！</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><a id="more"></a>
<p>有这样一个模块A，A模块是以前写的，A模块的所有子模块都是通过左侧菜单列表形式展现的，即一堆的&lt;li&gt;&lt;/li&gt;元素组成，这些li元素全都是通过jsp脚本语言生成的。现在需要为A模块添加另外一个子模块C，而子模块C的响应时间非常长，因此需要异步来构造。异步构造好了之后，发现新增加的子模块C没有了其他子模块的特效（因为整个页面一出来，通过jsp脚本创建的li元素都已经绑定好了事件），比如点击之后展开子模块的子模块，并改变自身的样式等等效果。此时想到的第一个问题就是，我没有为新增加的子模块C添加特效的事件监听。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>为子模块C添加事件监听。即通过<code>$(&quot;#C&quot;).off(&quot;click&quot;).on(&quot;click&quot;,function(){});</code>这样的方式来监听，添加完之后，确实可以达到我想要的效果。</li>
<li>自以为一切尽在掌握，偏偏是人外有人，天外有天啊。看到同事小丸子的写法是<code>$(document).on(&quot;click&quot;,&quot;#C&quot;,function(){});</code>，这段是在一开始初始化的时候就监听的，动态创建的子模块就都不用再监听click事件了</li>
</ol>
<h2 id="document-on-39-click-39-39-id-39-function-vs-39-id-39-on-39-click-39-function-两者的区别"><a href="#document-on-39-click-39-39-id-39-function-vs-39-id-39-on-39-click-39-function-两者的区别" class="headerlink" title="$(document).on(&#39;click&#39;,&#39;#id&#39;,function(){}) vs $(&#39;#id&#39;).on(&#39;click&#39;,function(){})两者的区别"></a><code>$(document).on(&#39;click&#39;,&#39;#id&#39;,function(){}) vs $(&#39;#id&#39;).on(&#39;click&#39;,function(){})</code>两者的区别</h2><p>发现事情的神奇之后，我开始寻找$(document).on()来绑定事件的原因了。</p>
<blockquote>
<p><strong>$(document).on(“click”,”#C”,function(){}) :</strong></p>
<p>通过将事件绑定到更高层的Dom tree上面(在这里是document对象)    这样事件处理器就会在事件到达选择器选中的元素的时候触发。（通过代理一个事件处理器这样的方式，这样的话即使元素在绑定事件的时候不存在DOM Tree上面，而是后续动态创建的，也会被执行。）</p>
<p><strong>$(“#C).on(function(){}) :</strong></p>
<p>如果使用这种方式，并且 #C 的元素是在绑定事件之后创建的，那么事件处理函数将永远不会被执行。使用这个方式来监听事件，你要确保在你绑定事件之前，#C元素在DOM里已经存在了。</p>
</blockquote>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://stackoverflow.com/questions/14879168/document-onclick-id-function-vs-id-onclick-function" target="_blank" rel="external">$(document).on(‘click’, ‘#id’, function() {}) VS $(‘#id’).on(‘click’, function(){})</a></p>
]]></content>
    
    <summary type="html">
    
      $(document).on(&#39;click&#39;, &#39;#id&#39;, function() {}) vs $(&#39;#id&#39;).on(&#39;click&#39;, function(){})
    
    </summary>
    
    
      <category term="JQuery" scheme="http://webinglin.github.io/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习札记 第十篇 分片集群搭建</title>
    <link href="http://webinglin.github.io/2015/06/10/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AF%87-%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://webinglin.github.io/2015/06/10/MongoDB学习札记-第十篇-分片集群搭建/</id>
    <published>2015-06-10T05:38:42.000Z</published>
    <updated>2016-12-17T17:56:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>##实验环境准备：</p>
<p><strong>configSerer</strong></p>
<blockquote>
<p>192.168.236.131:27000</p>
</blockquote>
<p><strong>mongos</strong></p>
<blockquote>
<p>192.168.236.131:28000</p>
</blockquote>
<p><strong>shards</strong></p>
<blockquote>
<p>192.168.236.131:29001</p>
<p>192.168.236.131:29002</p>
<p>192.168.236.131:29003</p>
</blockquote>
<a id="more"></a>
<h4 id="第一步-创建分片实验需要的目录"><a href="#第一步-创建分片实验需要的目录" class="headerlink" title="第一步: 创建分片实验需要的目录"></a>第一步: 创建分片实验需要的目录</h4><pre><code>root@ubuntu:~# mkdir -p ~/mongoData/shard/s1
root@ubuntu:~# mkdir -p ~/mongoData/shard/s2
root@ubuntu:~# mkdir -p ~/mongoData/shard/s3
root@ubuntu:~# mkdir -p ~/mongoData/shard/log
root@ubuntu:~# mkdir -p ~/mongoData/shard/config
</code></pre><h4 id="第二步：-启动configServer"><a href="#第二步：-启动configServer" class="headerlink" title="第二步： 启动configServer"></a>第二步： 启动configServer</h4><pre><code>root@ubuntu:~# mongod --configsvr --dbpath ~/mongoData/shard/config/ --fork --logpath ~/mongoData/shard/log/configsvr.log --logappend --port 27000
</code></pre><h4 id="第三步：-启动mongos"><a href="#第三步：-启动mongos" class="headerlink" title="第三步：　启动mongos"></a>第三步：　启动mongos</h4><pre><code>root@ubuntu:~# mongos --configdb 192.168.236.131:27000 --port 28000 --fork --logpath ~/mongoData/shard/log/mongs.log
</code></pre><h4 id="第四步：-启动所有的shard分片"><a href="#第四步：-启动所有的shard分片" class="headerlink" title="第四步： 启动所有的shard分片"></a>第四步： 启动所有的shard分片</h4><pre><code>root@ubuntu:~/mongoData# mongod --dbpath ~/mongoData/shard/s1/ --port 29001 --fork --logpath ~/mongoData/shard/log/s1.log --shardsvr --logappend    
root@ubuntu:~/mongoData# mongod --dbpath ~/mongoData/shard/s2/ --port 29002 --fork --logpath ~/mongoData/shard/log/s2.log --shardsvr --logappend
root@ubuntu:~/mongoData# mongod --dbpath ~/mongoData/shard/s3/ --port 29003 --fork --logpath ~/mongoData/shard/log/s3.log --shardsvr --logappend
</code></pre><h4 id="第五步：-将shard添加到mongos中-并配置"><a href="#第五步：-将shard添加到mongos中-并配置" class="headerlink" title="第五步： 将shard添加到mongos中    并配置"></a>第五步： 将shard添加到mongos中    并配置</h4><pre><code>root@ubuntu:~/mongoData# mongo --port 28000
MongoDB shell version: 3.0.3
connecting to: 127.0.0.1:28000/test
... ...
mongos&gt; use admin
switched to db admin
mongos&gt; sh.addShard(&quot;192.168.236.131:29001&quot;)
{ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }
mongos&gt; sh.addShard(&quot;192.168.236.131:29002&quot;)
{ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }
mongos&gt; sh.addShard(&quot;192.168.236.131:29003&quot;)
{ &quot;shardAdded&quot; : &quot;shard0002&quot;, &quot;ok&quot; : 1 }
mongos&gt;
</code></pre><p><br><br>使用下面两个命令来配置需要分片的数据库及集合以及对应的片键</p>
<p>sh.enableSharding(“<database>“)</database></p>
<p>sh.shardCollection(“<database>.<collection>“, shard-key-pattern)</collection></database></p>
<pre><code>mongos&gt; sh.enableSharding(&quot;test&quot;)
{ &quot;ok&quot; : 1 }
mongos&gt; sh.shardCollection(&quot;test.users&quot;,{&quot;username&quot;:1,&quot;_id&quot;:1})
{ &quot;collectionsharded&quot; : &quot;test.users&quot;, &quot;ok&quot; : 1 }
mongos&gt;
</code></pre><p>如果是添加副本集作为分片怎么处理？</p>
<blockquote>
<p><strong>addShard</strong></p>
<p>The hostname and port of the mongod instance to be added as a shard. To add a replica set as a shard, specify the name of the replica set and the hostname and port of a member of the replica set.</p>
</blockquote>
<p>上面这段话引用自官网，也就是说，我们只需要指定副本集的名称然后再指定其中一台机器即可。</p>
<p>比如： </p>
<blockquote>
<p>sh.addShard(“replicaSet0/&lt;ont host of the replica set&gt;:&lt;port&gt;”);</p>
</blockquote>
<h4 id="验证分片集群部署情况"><a href="#验证分片集群部署情况" class="headerlink" title="验证分片集群部署情况"></a>验证分片集群部署情况</h4><p>先往mongos插入100条数据，然后通过 db.users.stats() 查看集合的状态，发现集合被切分到三个分片中了，虽然第一个分片数据量比较多，其他两个分片数据量相对较少 （这个和片键 sharding key 的设置有关，我没有详细看官网关于shard key设置的文章，所以这里的片键设置比较简单，随意。）</p>
<pre><code>mongos&gt; for(var i=0; i&lt;100; i++) {
... db.users.insert({&quot;username&quot;:&quot;&quot; + i,age:i*2 , addr:&quot;ardr&quot;+i})
... }
WriteResult({ &quot;nInserted&quot; : 1 })
mongos&gt; db.users.stats()
{
        &quot;sharded&quot; : true,
        &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only.&quot;,
        &quot;userFlags&quot; : 1,
        &quot;capped&quot; : false,
        &quot;ns&quot; : &quot;test.users&quot;,
        &quot;count&quot; : 100,
        &quot;numExtents&quot; : 4,
        &quot;size&quot; : 11200,
        &quot;storageSize&quot; : 57344,
        &quot;totalIndexSize&quot; : 49056,
        &quot;indexSizes&quot; : {
                &quot;_id_&quot; : 24528,
                &quot;username_1__id_1&quot; : 24528
        },
        &quot;avgObjSize&quot; : 112,
        &quot;nindexes&quot; : 2,
        &quot;nchunks&quot; : 3,
        &quot;shards&quot; : {
                &quot;shard0000&quot; : {
                        &quot;ns&quot; : &quot;test.users&quot;,
                        &quot;count&quot; : 88,
                        &quot;size&quot; : 9856,
                        &quot;avgObjSize&quot; : 112,
                        &quot;numExtents&quot; : 2,
                        &quot;storageSize&quot; : 40960,
                        &quot;lastExtentSize&quot; : 32768,
                        &quot;paddingFactor&quot; : 1,
                        &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only.&quot;,
                        &quot;userFlags&quot; : 1,
                        &quot;capped&quot; : false,
                        &quot;nindexes&quot; : 2,
                        &quot;totalIndexSize&quot; : 16352,
                        &quot;indexSizes&quot; : {
                                &quot;_id_&quot; : 8176,
                                &quot;username_1__id_1&quot; : 8176
                        },
                        &quot;ok&quot; : 1
                },
                &quot;shard0001&quot; : {
                        &quot;ns&quot; : &quot;test.users&quot;,
                        &quot;count&quot; : 11,
                        &quot;size&quot; : 1232,
                        &quot;avgObjSize&quot; : 112,
                        &quot;numExtents&quot; : 1,
                        &quot;storageSize&quot; : 8192,
                        &quot;lastExtentSize&quot; : 8192,
                        &quot;paddingFactor&quot; : 1,
                        &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only.&quot;,
                        &quot;userFlags&quot; : 1,
                        &quot;capped&quot; : false,
                        &quot;nindexes&quot; : 2,
                        &quot;totalIndexSize&quot; : 16352,
                        &quot;indexSizes&quot; : {
                                &quot;_id_&quot; : 8176,
                                &quot;username_1__id_1&quot; : 8176
                        },
                        &quot;ok&quot; : 1
                },
                &quot;shard0002&quot; : {
                        &quot;ns&quot; : &quot;test.users&quot;,
                        &quot;count&quot; : 1,
                        &quot;size&quot; : 112,
                        &quot;avgObjSize&quot; : 112,
                        &quot;numExtents&quot; : 1,
                        &quot;storageSize&quot; : 8192,
                        &quot;lastExtentSize&quot; : 8192,
                        &quot;paddingFactor&quot; : 1,
                        &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only.&quot;,
                        &quot;userFlags&quot; : 1,
                        &quot;capped&quot; : false,
                        &quot;nindexes&quot; : 2,
                        &quot;totalIndexSize&quot; : 16352,
                        &quot;indexSizes&quot; : {
                                &quot;_id_&quot; : 8176,
                                &quot;username_1__id_1&quot; : 8176
                        },
                        &quot;ok&quot; : 1
                }
        },
        &quot;ok&quot; : 1
}
</code></pre><p>这时候如果用mongo客户端去连接 29001 , 29002， 29003端口，会发现只有集合的部分数据是可见的，这也证明了我们实验成功了</p>
<pre><code>root@ubuntu:~/mongoData# mongo --port 29001
MongoDB shell version: 3.0.3
connecting to: 127.0.0.1:29001/test
... ...
&gt; db.users.find().count()
88
&gt; exit
bye
root@ubuntu:~/mongoData# mongo --port 29002
MongoDB shell version: 3.0.3
connecting to: 127.0.0.1:29002/test
... ...
&gt; db.users.find().count()
11
&gt; exit
bye
root@ubuntu:~/mongoData# mongo --port 29003
MongoDB shell version: 3.0.3
connecting to: 127.0.0.1:29003/test
... ...
&gt; db.users.find().count()
1
&gt; exit
bye
root@ubuntu:~/mongoData#
</code></pre><p>整个分片的实验基本上已经验证成功了。</p>
<p>如果某个集合没有进行分片，数据会存放在primary shard里面。 </p>
<pre><code>mongos&gt; db.sites.insert({&quot;site&quot;:&quot;webinglin.github.io&quot;,&quot;author&quot;:&quot;linwenbin&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
... ...
mongos&gt; db.sites.insert({&quot;site&quot;:&quot;webinglin.github.io&quot;,&quot;author&quot;:&quot;linwenbin&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
mongos&gt; db.sites.stats()
{
        &quot;sharded&quot; : false,
        &quot;primary&quot; : &quot;shard0000&quot;,
        &quot;ns&quot; : &quot;test.sites&quot;,
        &quot;count&quot; : 7,
        &quot;size&quot; : 784,
        &quot;avgObjSize&quot; : 112,
        &quot;numExtents&quot; : 1,
        &quot;storageSize&quot; : 8192,
        &quot;lastExtentSize&quot; : 8192,
        &quot;paddingFactor&quot; : 1,
        &quot;paddingFactorNote&quot; : &quot;paddingFactor is unused and unmaintained in 3.0. It remains hard coded to 1.0 for compatibility only.&quot;,
        &quot;userFlags&quot; : 1,
        &quot;capped&quot; : false,
        &quot;nindexes&quot; : 1,
        &quot;totalIndexSize&quot; : 8176,
        &quot;indexSizes&quot; : {
                &quot;_id_&quot; : 8176
        },
        &quot;ok&quot; : 1
}
mongos&gt;
</code></pre><blockquote>
<p>这篇文章介绍了简单的搭建分片集群的步骤。更多关于怎么选择片键（Shard Key)，参考<a href="http://docs.mongodb.org/manual/tutorial/choose-a-shard-key/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://docs.mongodb.org/manual/core/sharded-cluster-architectures-test/" target="_blank" rel="external">http://docs.mongodb.org/manual/core/sharded-cluster-architectures-test/</a></p>
<p><a href="http://docs.mongodb.org/manual/reference/sharding/" target="_blank" rel="external">http://docs.mongodb.org/manual/reference/sharding/</a></p>
]]></content>
    
    <summary type="html">
    
      MongoDB学习札记 第十篇 分片 测试架构实战
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://webinglin.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习札记 第九篇 分片核心概念</title>
    <link href="http://webinglin.github.io/2015/06/10/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AF%87-%E5%88%86%E7%89%87%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://webinglin.github.io/2015/06/10/MongoDB学习札记-第九篇-分片核心概念/</id>
    <published>2015-06-10T05:38:04.000Z</published>
    <updated>2016-12-17T17:55:36.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分片集群的组成"><a href="#分片集群的组成" class="headerlink" title="分片集群的组成"></a>分片集群的组成</h2><p><strong>Shards</strong></p>
<blockquote>
<p>A shard is a MongoDB instance that holds a subset of a collection’s data. Each shard is either a single mongod instance or a replica set. In production, all shards are replica sets. </p>
</blockquote>
<p><strong>Config Servers</strong></p>
<blockquote>
<p>Each config server is a mongod instance that holds metadata about the cluster. The metadata maps chunks to shards. </p>
</blockquote>
<p><strong>Routing Instances</strong></p>
<blockquote>
<p>Each router is a mongos instance that routes the reads and writes from applications to the shards. Applications do not access the shards directly.</p>
</blockquote>
<a id="more"></a>
<h2 id="为什么使用分片"><a href="#为什么使用分片" class="headerlink" title="为什么使用分片"></a>为什么使用分片</h2><ul>
<li>当本地磁盘不足的时候</li>
<li>请求量巨大导致内存爆满的情况</li>
<li>一台单独的mongod进程无法满足写的需求的情况</li>
</ul>
<blockquote>
<p><strong>重要</strong></p>
<p>部署分片集群是很花时间和资源的。如果你的系统已经能够达到或者超过了他的容量，那时候再去部署分片很难不影响到你现有的应用。</p>
<p>所以如果你觉得你的数据库在不久的将来需要进行分片，那么不要等到你的系统超过本身的承载能力的时候再去分片。</p>
<p>当你设计数据模型的时候，考虑分片的需求吧。</p>
</blockquote>
<p><img src="http://docs.mongodb.org/manual/_images/sharded-cluster.png" alt=""></p>
<h2 id="生产环境和测试环境-架构区别"><a href="#生产环境和测试环境-架构区别" class="headerlink" title="生产环境和测试环境 架构区别"></a>生产环境和测试环境 架构区别</h2><p><strong>生产环境下</strong></p>
<ul>
<li><p>配置服务器：三个配置服务并且每个配置服务都在不同的机器上，这样能够确保安全，三台配置服务也不一定是replica set的形式。可以是单独的三个mongod进程组成。</p>
</li>
<li><p>分片：生成环境下的分片采用Replica Set的形式。至少两个分片。</p>
</li>
<li><p>Mongos实例：至少一个mongos进程。</p>
</li>
</ul>
<p><img src="http://docs.mongodb.org/manual/_images/sharded-cluster-production-architecture.png" alt=""></p>
<p><strong>测试环境或者开发环境</strong></p>
<ul>
<li>一个配置服务器（一个mongod进程）</li>
<li>至少一个分片（分片可以是单独的mongod进程或者 replica set == 一组mongod进程）</li>
<li>一个mongos实例（一个mongos实例最好对应一个应用容器 == 比如一台servlet容器的话，就相应的部署一个mongos实例）</li>
</ul>
<p><img src="http://docs.mongodb.org/manual/_images/sharded-cluster-test-architecture.png" alt=""></p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://docs.mongodb.org/manual/core/sharding-introduction/" target="_blank" rel="external">http://docs.mongodb.org/manual/core/sharding-introduction/</a></p>
]]></content>
    
    <summary type="html">
    
      MongoDB学习札记 第九篇 分片核心概念
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://webinglin.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习札记 第八篇 Replica Set 实战</title>
    <link href="http://webinglin.github.io/2015/06/09/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AF%87-Replica-Set-%E5%AE%9E%E6%88%98/"/>
    <id>http://webinglin.github.io/2015/06/09/MongoDB学习札记-第八篇-Replica-Set-实战/</id>
    <published>2015-06-09T05:43:38.000Z</published>
    <updated>2016-12-17T17:55:20.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Ubuntu12.0.4</li>
<li>mongodb3.0.3</li>
<li>三台机器，分别为： 192.168.236.131 ;  192.168.236.133 ;  192.168.236.134</li>
</ul>
<p>如果对于怎么安装Mongodb还不清楚的同学可以查看我之前的学习札记</p>
<a id="more"></a>
<p>第一步：</p>
<p>在三台机器上分别运行（都要运行）</p>
<pre><code>root@ubuntu:/usr/local/mongodb#    mongod --dbpath /usr/local/mongodb/data --replSet rs0
</code></pre><p>注意这里的 –replSet 参数指定了副本集的名称，每一个副本集都有一个唯一的名称。</p>
<p>运行之后可以看到下面这样的信息：</p>
<pre><code>2015-06-09T17:54:20.845-0700 I JOURNAL  [initandlisten] journal dir=/usr/local/mongodb/data/journal
2015-06-09T17:54:20.846-0700 I JOURNAL  [initandlisten] recover : no journal files present, no recovery needed
2015-06-09T17:54:20.925-0700 I JOURNAL  [durability] Durability thread started
2015-06-09T17:54:20.926-0700 I JOURNAL  [journal writer] Journal writer thread started
2015-06-09T17:54:20.931-0700 I CONTROL  [initandlisten] MongoDB starting : pid=2539 port=27017 dbpath=/usr/local/mongodb/data/ 64-bit host=ubuntu
2015-06-09T17:54:20.931-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:54:20.931-0700 I CONTROL  [initandlisten]
2015-06-09T17:54:20.932-0700 I CONTROL  [initandlisten]
2015-06-09T17:54:20.932-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:54:20.932-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:54:20.932-0700 I CONTROL  [initandlisten]
2015-06-09T17:54:20.932-0700 I CONTROL  [initandlisten] db version v3.0.3
2015-06-09T17:54:20.933-0700 I CONTROL  [initandlisten] git version: b40106b36eecd1b4407eb1ad1af6bc60593c6105
2015-06-09T17:54:20.933-0700 I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.1 14 Mar 2012
2015-06-09T17:54:20.933-0700 I CONTROL  [initandlisten] build info: Linux ip-10-216-207-166 3.2.0-36-virtual #57-Ubuntu SMP Tue Jan 8 22:04:49 UTC 2013 x86_64 BOOST_LIB_VERSION=1_49
2015-06-09T17:54:20.933-0700 I CONTROL  [initandlisten] allocator: tcmalloc
2015-06-09T17:54:20.933-0700 I CONTROL  [initandlisten] options: { replication: { replSet: &quot;rs0&quot; }, storage: { dbPath: &quot;/usr/local/mongodb/data/&quot; } }
2015-06-09T17:54:20.954-0700 I NETWORK  [initandlisten] waiting for connections on port 27017
2015-06-09T17:54:20.973-0700 W NETWORK  [ReplicationExecutor] Failed to connect to 192.168.236.134:27017, reason: errno:111 Connection refused
2015-06-09T17:54:20.974-0700 W NETWORK  [ReplicationExecutor] Failed to connect to 192.168.236.131:27017, reason: errno:111 Connection refused
2015-06-09T17:54:20.975-0700 I REPL     [ReplicationExecutor] New replica set config in use: { _id: &quot;rs0&quot;, version: 3, members: [ { _id: 1, host: &quot;192.168.236.133:27017&quot;, arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id: 2, host: &quot;192.168.236.134:27017&quot;, arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id: 3, host: &quot;192.168.236.131:27017&quot;, arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 } ], settings: { chainingAllowed: true, heartbeatTimeoutSecs: 10, getLastErrorModes: {}, getLastErrorDefaults: { w: 1, wtimeout: 0 } } }
2015-06-09T17:54:20.975-0700 I REPL     [ReplicationExecutor] This node is 192.168.236.133:27017 in the config
2015-06-09T17:54:20.975-0700 I REPL     [ReplicationExecutor] transition to STARTUP2
2015-06-09T17:54:20.975-0700 I REPL     [ReplicationExecutor] Starting replication applier threads
2015-06-09T17:54:20.977-0700 I REPL     [ReplicationExecutor] transition to RECOVERING
2
</code></pre><p>信息大概就是这样的，等到三台机器都启动完了之后。使用mongo客户端登录其中一台mongod服务器。这里我登录到 192.168.236.131 这台机器</p>
<pre><code>root@ubuntu:~# mongo
</code></pre><p>登录之后要切换到admin数据库，这样我们可以进行副本集的配置，具体怎么配置，代码如下：</p>
<pre><code>&gt; use admin
switched to db admin
&gt; config = {_id:&quot;rs0&quot;,members:[
... {_id:0,host:&quot;192.168.236.131:27017&quot;},
... {_id:1,host:&quot;192.168.236.133:27017&quot;},
... {_id:2,host:&quot;192.168.236.134:27017&quot;}]}
{
        &quot;_id&quot; : &quot;rs0&quot;,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 0,
                        &quot;host&quot; : &quot;192.168.236.131:27017&quot;
                },
                {
                        &quot;_id&quot; : 1,
                        &quot;host&quot; : &quot;192.168.236.133:27017&quot;
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;host&quot; : &quot;192.168.236.134:27017&quot;
                }
        ]
}
&gt; rs.initiate(config);
{ &quot;ok&quot; : 1 }
</code></pre><p>先定义 config 的配置信息， 然后通过 rs.initiate(config) 方法，将配置信息初始化。这两个步骤完成之后就表示我们的副本集配置信息初始化完成了，在这个rs0的副本集中我们定义了三台主机（注意在定义配置信息的时候指定的 _id 必须和我们启动mongod的时候指定的参数 –replSet 这个参数的值是一样的。）</p>
<p>过一会，mongodb就会帮我们选举出Primary节点和Secondary节点了。那在mongo客户端，我们可以通过 rs.status() 来查看副本集的状态信息</p>
<pre><code>rs0:OTHER&gt;
rs0:PRIMARY&gt; rs.status()
{
        &quot;set&quot; : &quot;rs0&quot;,
        &quot;date&quot; : ISODate(&quot;2015-06-10T00:10:06.941Z&quot;),
        &quot;myState&quot; : 1,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 0,
                        &quot;name&quot; : &quot;192.168.236.131:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 468,
                        &quot;optime&quot; : Timestamp(1433894773, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:06:13Z&quot;),
                        &quot;electionTime&quot; : Timestamp(1433894777, 1),
                        &quot;electionDate&quot; : ISODate(&quot;2015-06-10T00:06:17Z&quot;),
                        &quot;configVersion&quot; : 1,
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 233,
                        &quot;optime&quot; : Timestamp(1433894773, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:06:13Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:10:06.278Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:10:06.245Z&quot;),
                        &quot;pingMs&quot; : 1,
                        &quot;configVersion&quot; : 1
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 233,
                        &quot;optime&quot; : Timestamp(1433894773, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:06:13Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:10:05.943Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:10:05.890Z&quot;),
                        &quot;pingMs&quot; : 1,
                        &quot;configVersion&quot; : 1
                }
        ],
        &quot;ok&quot; : 1
}
</code></pre><p>其中name表示我么你的主机， health表示主机是否健康（0/1） , state（主节点还是从节点,或者是不可达节点)</p>
<p>如果上面信息正常显示出来说明整个副本集群已经建立起来了。这时候我们来验证一下是否是真的能够自动备份数据，是否能够自动从失败中恢复，自动选举新的Primary节点。</p>
<p>这个实验我们这样来做： </p>
<ol>
<li>先往Primary节点插入数据（131那台机器）</li>
<li>在133和134两台Secondary节点中查询数据，验证是否能够正常的同步机器。</li>
</ol>
<pre><code>rs0:PRIMARY&gt; use test
switched to db test
rs0:PRIMARY&gt; show collections
rs0:PRIMARY&gt; db.guids.insert({&quot;name&quot;:&quot;replica set&quot;,&quot;author&quot;:&quot;webinglin&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
rs0:PRIMARY&gt; exit
bye
root@ubuntu:~# mongo --host 192.168.236.134
MongoDB shell version: 3.0.3
connecting to: 192.168.236.134:27017/test
Server has startup warnings:
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not re                                      commended.
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; show dbs
2015-06-09T17:13:49.138-0700 E QUERY    Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }
    at Error (&lt;anonymous&gt;)
    at Mongo.getDBs (src/mongo/shell/mongo.js:47:15)
    at shellHelper.show (src/mongo/shell/utils.js:630:33)
    at shellHelper (src/mongo/shell/utils.js:524:36)
    at (shellhelp2):1:1 at src/mongo/shell/mongo.js:47
rs0:SECONDARY&gt; use test
switched to db test
rs0:SECONDARY&gt; db.guids.find()
Error: error: { &quot;$err&quot; : &quot;not master and slaveOk=false&quot;, &quot;code&quot; : 13435 }
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
rs0:SECONDARY&gt; show collections()
2015-06-09T17:14:24.219-0700 E QUERY    Error: don&apos;t know how to show [collections()]
    at Error (&lt;anonymous&gt;)
    at shellHelper.show (src/mongo/shell/utils.js:733:11)
    at shellHelper (src/mongo/shell/utils.js:524:36)
    at (shellhelp2):1:1 at src/mongo/shell/utils.js:733
rs0:SECONDARY&gt; show collections
guids
system.indexes
rs0:SECONDARY&gt; exit
bye
root@ubuntu:~# mongo --host 192.168.236.133
MongoDB shell version: 3.0.3
connecting to: 192.168.236.133:27017/test
Server has startup warnings:
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not re                                      commended.
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; show dbs
local  1.078GB
test   0.078GB
rs0:SECONDARY&gt; use test
switched to db test
rs0:SECONDARY&gt; show collections
guids
system.indexes
rs0:SECONDARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
rs0:SECONDARY&gt; exit
bye
</code></pre><p>至此，整个验证过程说明了我们集群部署是成功的。数据能够正常同步了。那么接下来我们还要验证另一种情况，Primary异常终止之后（131），另外两个Secondary节点会不会自动选举出新的Primary节点呢？ 这个实验我们这样处理： 将131机器的mongod服务停止掉。然后再来连接133或者134任意一台机器，通过rs.status()查看集群状态。</p>
<p>通过 ps -e | grep mongod 查看mongod服务是否开启，然后通过 killall mongod 或者 kill -15 &lt;进程号&gt;  来杀死mongod进程 </p>
<pre><code>root@ubuntu:~# ps -e | grep mongod
 3279 pts/0    00:00:19 mongod
root@ubuntu:~# killall mongod
root@ubuntu:~# mongo --host 192.168.236.133
MongoDB shell version: 3.0.3
connecting to: 192.168.236.133:27017/test
Server has startup warnings:
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.status()
{
        &quot;set&quot; : &quot;rs0&quot;,
        &quot;date&quot; : ISODate(&quot;2015-06-10T00:22:40.283Z&quot;),
        &quot;myState&quot; : 2,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 0,
                        &quot;name&quot; : &quot;192.168.236.131:27017&quot;,
                        &quot;health&quot; : 0,
                        &quot;state&quot; : 8,
                        &quot;stateStr&quot; : &quot;(not reachable/healthy)&quot;,
                        &quot;uptime&quot; : 0,
                        &quot;optime&quot; : Timestamp(0, 0),
                        &quot;optimeDate&quot; : ISODate(&quot;1970-01-01T00:00:00Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:22:39.642Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:18:22.292Z&quot;),
                        &quot;pingMs&quot; : 3,
                        &quot;lastHeartbeatMessage&quot; : &quot;Failed attempt to connect to 192.168.236.131:27017; couldn&apos;t connect to server 192.168.236.131:27017 (192.168.236.131), connection attempt failed&quot;,
                        &quot;configVersion&quot; : -1
                },
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 1169,
                        &quot;optime&quot; : Timestamp(1433895342, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:15:42Z&quot;),
                        &quot;configVersion&quot; : 1,
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 986,
                        &quot;optime&quot; : Timestamp(1433895342, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:15:42Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:22:38.952Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:22:38.951Z&quot;),
                        &quot;pingMs&quot; : 6,
                        &quot;electionTime&quot; : Timestamp(1433895503, 1),
                        &quot;electionDate&quot; : ISODate(&quot;2015-06-10T00:18:23Z&quot;),
                        &quot;configVersion&quot; : 1
                }
        ],
        &quot;ok&quot; : 1
}
rs0:SECONDARY&gt; exit
bye
</code></pre><p>通过上面这段代码的观察，我们发现，当把原来的Primary节点停止掉后（131停止）， 那么整个mongodb的副本集群会重新选举出新的Primary节点（ 134 机器）</p>
<p>为了验证一下新选举的Primary是否正常，我们再次验证一把数据的同步情况，先 连接到134 主节点，将原来的数据删掉，在到133进行验证，数据是否也被删除</p>
<pre><code>root@ubuntu:~# mongo --192.168.236.134
Error parsing command line: unknown option 192.168.236.134
try &apos;mongo --help&apos; for more information
root@ubuntu:~# mongo --host 192.168.236.134
MongoDB shell version: 3.0.3
connecting to: 192.168.236.134:27017/test
Server has startup warnings:
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
rs0:PRIMARY&gt; use test
switched to db test
rs0:PRIMARY&gt; show collections
guids
system.indexes
rs0:PRIMARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
{ &quot;_id&quot; : ObjectId(&quot;557781aed5ed7ed61c16abfd&quot;), &quot;name&quot; : &quot;mongodb&quot; }
rs0:PRIMARY&gt; db.guids.remove({name:&quot;mongodb&quot;})
WriteResult({ &quot;nRemoved&quot; : 1 })
rs0:PRIMARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
rs0:PRIMARY&gt; exit
bye
root@ubuntu:~# mongo --host 192.168.236.133
MongoDB shell version: 3.0.3
connecting to: 192.168.236.133:27017/test
Server has startup warnings:
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
rs0:SECONDARY&gt; exit
bye
</code></pre><p>实践后发现，先选举的Primary节点也正常工作。我们的整个Mongodb副本集群测试完成。</p>
<h2 id="动态添加节点，删除节点。"><a href="#动态添加节点，删除节点。" class="headerlink" title="动态添加节点，删除节点。"></a>动态添加节点，删除节点。</h2><p>在开始这个实验之前，先把131的机器重新启动，然后用mongo客户端连到131进行验证数据是否也同步了。</p>
<p>登录131之后，我们发现数据也同步了，然后131节点变成了 Secondary节点了。</p>
<pre><code>root@ubuntu:~# mongo
MongoDB shell version: 3.0.3
connecting to: test
Server has startup warnings:
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.status()
{
        &quot;set&quot; : &quot;rs0&quot;,
        &quot;date&quot; : ISODate(&quot;2015-06-10T00:25:02.631Z&quot;),
        &quot;myState&quot; : 2,
        &quot;syncingTo&quot; : &quot;192.168.236.133:27017&quot;,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 0,
                        &quot;name&quot; : &quot;192.168.236.131:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 14,
                        &quot;optime&quot; : Timestamp(1433895834, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:23:54Z&quot;),
                        &quot;syncingTo&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;configVersion&quot; : 1,
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 13,
                        &quot;optime&quot; : Timestamp(1433895834, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:23:54Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:25:01.196Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:25:02.228Z&quot;),
                        &quot;pingMs&quot; : 1,
                        &quot;syncingTo&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;configVersion&quot; : 1
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 13,
                        &quot;optime&quot; : Timestamp(1433895834, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:23:54Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:25:01.235Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:25:02.446Z&quot;),
                        &quot;pingMs&quot; : 10,
                        &quot;electionTime&quot; : Timestamp(1433895503, 1),
                        &quot;electionDate&quot; : ISODate(&quot;2015-06-10T00:18:23Z&quot;),
                        &quot;configVersion&quot; : 1
                }
        ],
        &quot;ok&quot; : 1
}
rs0:SECONDARY&gt; exit
bye
</code></pre><p>登录到134 Primary节点，通过  rs.remove() 方法来删除副本集中的某一个节点，这里我们还是将 131删除。删除之后我们还往134主节点中加入数据.</p>
<pre><code>rs0:PRIMARY&gt; rs.remove(&quot;192.168.236.131:27017&quot;)
{ &quot;ok&quot; : 1 }
rs0:PRIMARY&gt; rs.status
function () { return db._adminCommand(&quot;replSetGetStatus&quot;); }
rs0:PRIMARY&gt; rs.status()
{
        &quot;set&quot; : &quot;rs0&quot;,
        &quot;date&quot; : ISODate(&quot;2015-06-10T00:32:15.795Z&quot;),
        &quot;myState&quot; : 1,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 1562,
                        &quot;optime&quot; : Timestamp(1433896329, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:32:09Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:32:13.909Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:32:15.633Z&quot;),
                        &quot;pingMs&quot; : 1,
                        &quot;syncingTo&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;configVersion&quot; : 2
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 1729,
                        &quot;optime&quot; : Timestamp(1433896329, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:32:09Z&quot;),
                        &quot;electionTime&quot; : Timestamp(1433895503, 1),
                        &quot;electionDate&quot; : ISODate(&quot;2015-06-10T00:18:23Z&quot;),
                        &quot;configVersion&quot; : 2,
                        &quot;self&quot; : true
                }
        ],
        &quot;ok&quot; : 1
}
rs0:PRIMARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
rs0:PRIMARY&gt; db.guids.insert({&quot;name&quot;:&quot;remove one node dync&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
rs0:PRIMARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
{ &quot;_id&quot; : ObjectId(&quot;557785bcbb56172c8e069341&quot;), &quot;name&quot; : &quot;remove one node dync&quot; }
rs0:PRIMARY&gt; exit
bye
</code></pre><p>删除131节点后，我们往primary节点中加入了新的数据，然后先不要将131的mongod服务停掉，我们通过mongo连接到131的mongod服务来查看数据</p>
<pre><code>root@ubuntu:~# mongo --host 192.168.236.131
MongoDB shell version: 3.0.3
connecting to: 192.168.236.131:27017/test
Server has startup warnings:
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten]
&gt; db.guids.find()
Error: error: { &quot;$err&quot; : &quot;not master and slaveOk=false&quot;, &quot;code&quot; : 13435 }
&gt; db.slaveOk()
2015-06-09T17:33:40.243-0700 E QUERY    TypeError: Property &apos;slaveOk&apos; of object test is not a function
    at (shell):1:4
&gt; rs.slaveOk()
&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
&gt; exit
bye
</code></pre><p>实验结果可以知道，我们在134新加入的数据 {name:”remove one node dync”} 并没有同步到131（已从副本集中删除）.</p>
<p>为了让实验结果更加确切，我们查看133是否有同步了数据:</p>
<pre><code>root@ubuntu:~# mongo --host 192.168.236.133
MongoDB shell version: 3.0.3
connecting to: 192.168.236.133:27017/test
Server has startup warnings:
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.647-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:11.648-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
{ &quot;_id&quot; : ObjectId(&quot;557785bcbb56172c8e069341&quot;), &quot;name&quot; : &quot;remove one node dync&quot; }
rs0:SECONDARY&gt; exit
bye
</code></pre><p>实验数据可以看到，133同步了在134主节点中新增的文档 {“name”:”remove one node dync”}，这样就证明了动态删除副本集中的某一个节点的实验成功了。那怎么动态添加节点到副本集中呢？</p>
<p>原理是一样的，但是调用的方法变成了    <code>rs.add(&quot;192.168.236.131:27017&quot;)</code></p>
<pre><code>root@ubuntu:~# mongo --host 192.168.236.134
MongoDB shell version: 3.0.3
connecting to: 192.168.236.134:27017/test
Server has startup warnings:
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:03:27.744-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:03:27.745-0700 I CONTROL  [initandlisten]
rs0:PRIMARY&gt; rs.add(&quot;192.168.236.131:27017&quot;);
{ &quot;ok&quot; : 1 }
rs0:PRIMARY&gt; rs.status()
{
        &quot;set&quot; : &quot;rs0&quot;,
        &quot;date&quot; : ISODate(&quot;2015-06-10T00:34:45.974Z&quot;),
        &quot;myState&quot; : 1,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;192.168.236.133:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 1712,
                        &quot;optime&quot; : Timestamp(1433896482, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:34:42Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:34:44.207Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:34:45.901Z&quot;),
                        &quot;pingMs&quot; : 2,
                        &quot;syncingTo&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;configVersion&quot; : 3
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 1879,
                        &quot;optime&quot; : Timestamp(1433896482, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:34:42Z&quot;),
                        &quot;electionTime&quot; : Timestamp(1433895503, 1),
                        &quot;electionDate&quot; : ISODate(&quot;2015-06-10T00:18:23Z&quot;),
                        &quot;configVersion&quot; : 3,
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 3,
                        &quot;name&quot; : &quot;192.168.236.131:27017&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 1,
                        &quot;optime&quot; : Timestamp(1433896329, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2015-06-10T00:32:09Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-06-10T00:34:44.217Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-06-10T00:34:44.234Z&quot;),
                        &quot;pingMs&quot; : 1,
                        &quot;syncingTo&quot; : &quot;192.168.236.134:27017&quot;,
                        &quot;configVersion&quot; : 3
                }
        ],
        &quot;ok&quot; : 1
}
rs0:PRIMARY&gt; exit
bye
</code></pre><p>在rs.status()返回的结果中可以看到，131节点已经成功加入副本集中了。加入之后，理论上应该会把在134主节点加入的数据同步过来，刚才删除之后是不会同步的。那这时候重新加入副本集，应该是要同步的。下面是实验结果：</p>
<pre><code>root@ubuntu:~# mongo
MongoDB shell version: 3.0.3
connecting to: test
Server has startup warnings:
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.146-0700 I CONTROL  [initandlisten]
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten] **        We suggest setting it to &apos;never&apos;
2015-06-09T17:24:49.147-0700 I CONTROL  [initandlisten]
rs0:SECONDARY&gt; rs.slaveOk()
rs0:SECONDARY&gt; db.guids.find()
{ &quot;_id&quot; : ObjectId(&quot;557780ebd147e9391020860d&quot;), &quot;name&quot; : &quot;replica set&quot;, &quot;author&quot; : &quot;webinglin&quot; }
{ &quot;_id&quot; : ObjectId(&quot;557785bcbb56172c8e069341&quot;), &quot;name&quot; : &quot;remove one node dync&quot; }
rs0:SECONDARY&gt; exit
bye
</code></pre><p>实验结果显示，动态添加操作也正常。动态的将131节点加入到副本集中能够保证数据同步成功。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>在调用 rs.add(“host:ip”) 或者 rs.remove(“host:ip”) 的时候，必须要在 Primary 节点中进行。</p>
</blockquote>
<p>add方法可以加入一个document对象，这样就可以在指定具体的Secondary节点的更多的设置项了，比如指定为priority: 0 或 priority: 0,hidden: true 或 priority:0,hidden:true,arbiterOnly:true</p>
<pre><code>{
  _id: &lt;int&gt;,
  host: &lt;string&gt;,
  arbiterOnly: &lt;boolean&gt;,
  buildIndexes: &lt;boolean&gt;,
  hidden: &lt;boolean&gt;,
  priority: &lt;number&gt;,
  tags: &lt;document&gt;,
  slaveDelay: &lt;int&gt;,
  votes: &lt;number&gt;
}
</code></pre><p><strong>怎么对副本集进行权限验证，参考主从复制的安全部分，也是通过openssl来生成keyfile，然后再启动mongod的时候指定keyFile来设置安全的</strong></p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="docs.mongodb.org/manual/">《官网手册》</a></li>
<li>《MongoDB权威指南》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      MongoDB学习札记 第八篇 Replica Set 实战
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://webinglin.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习札记 第七篇 Replica Set 核心概念</title>
    <link href="http://webinglin.github.io/2015/06/09/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AF%87-Replica-Set-%E6%A6%82%E5%BF%B5/"/>
    <id>http://webinglin.github.io/2015/06/09/MongoDB学习札记-第七篇-Replica-Set-概念/</id>
    <published>2015-06-09T03:27:49.000Z</published>
    <updated>2016-12-17T17:56:07.195Z</updated>
    
    <content type="html"><![CDATA[<p>副本集是一组mongod进程组成的，提供了数据冗余和高可用性。</p>
<h2 id="副本集的成员"><a href="#副本集的成员" class="headerlink" title="副本集的成员"></a>副本集的成员</h2><p><strong>Replica Set Primary</strong></p>
<blockquote>
<p>The primary is the only member of a replica set that accepts write operations.</p>
</blockquote>
<p><strong>Replica Set Secondary Members</strong></p>
<blockquote>
<p>Secondary members replicate the primary’s data set and accept read operations. If the set has no primary, a secondary <strong>can become primary.</strong></p>
</blockquote>
<p><strong>Priority 0 Replica Set Members</strong></p>
<blockquote>
<p>Priority 0 members are secondaries that <strong>cannot become the primary.</strong></p>
</blockquote>
<p><strong>Hidden Replica Set Members</strong></p>
<blockquote>
<p>Hidden members are secondaries that are invisible to applications. These members support dedicated workloads, such as reporting or <strong>backup.</strong></p>
</blockquote>
<p><strong>Replica Set Arbiter</strong></p>
<blockquote>
<p>An arbiter <strong>does not maintain a copy of the data set</strong> but participate in <strong>elections.</strong></p>
</blockquote>
<a id="more"></a>
<p>观察上面提到的集中成员，归根结底就是两种 Primary和Secondary，只不过Secondary根据不用的用途再次划分了。</p>
<blockquote>
<p>Most deployments, however, will keep three members that store data: A primary and two secondary members.</p>
</blockquote>
<p>这句话说明了正常情况下，会有一个primary节点和两个secondare节点。</p>
<p>在mongodb3.0.0以后的版本，最多可以有50个节点，但是只能有7个投票的节点</p>
<blockquote>
<p>Changed in version 3.0.0: A replica set can have up to 50 members but only 7 voting members</p>
</blockquote>
<p>那如果超过了50个节点，应该采用master-slave的模式了。但是master-slave的模式就不能自动的故障恢复了。(不能像副本集那样自动选举主节点)</p>
<p>##Primary节点<br>primary节点是在副本集中唯一能够接受写操作的节点。Mongodb将这些写操作应用到primary节点中，然后将这些操作记录在primary节点的oplog中。 Secondary节点复制这个oplog，并将里面的操作应用到自己的数据库中。（和Redis的aop备份方式一样的道理）</p>
<p><img src="http://docs.mongodb.org/manual/_images/replica-set-read-write-operations-primary.png" alt=""></p>
<p>在上图中，有三个节点的副本集，primary节点接受所有的写操作。然后Secondary节点从primary节点复制oplog并应用到他们的数据集里面。</p>
<p>所有的副本集成员都能够接受读的请求。但是默认情况下，应用程序会将读请求定向到primary节点、这个是可以修改的。</p>
<p>一个副本集最多只能拥有一个Primary节点，一旦这个Primary节点变得不可用了，副本集就会选出一个Secondary，让它成为新的Primary节点。</p>
<p><img src="http://docs.mongodb.org/manual/_images/replica-set-trigger-election.png" alt=""></p>
<h2 id="Secondary节点"><a href="#Secondary节点" class="headerlink" title="Secondary节点"></a>Secondary节点</h2><p>上文中提到了，Secondary节点维护者primary节点的数据拷贝。一个副本集能够拥有一个或多个Secondary节点。</p>
<p>尽管客户端不能往Secondary节点写入数据，但是能够从Secondary节点读取数据。</p>
<p>一个Secondary节点也能成为primary节点，当primary节点变得不可用的时候，Replica Sets（副本集）会选举出新的Primary节点（是否是Zookeeper的master选举方式呢？还不清楚）。</p>
<p>对于Secondary节点，我们可以根据不能的目的，将secondary节点配置成不同用途的secondary：</p>
<ul>
<li>Priority 0 Replica Set Members</li>
<li>Hidden Replica Set Members.</li>
<li>Delayed Replica Set Members.</li>
</ul>
<p><strong>Priority 0 Replica Set Members</strong></p>
<blockquote>
<p>阻止Secondary成为Primary节点，可用来让其一直处于secondar状态，只读。或者做冷备份。</p>
<p>如果一个副本集中的机器配置都不一样的话，可以将性能不那么优秀的机器配置成priority 0 的 Secondary节点。这样的话就能够保证只有高性能机器能够成为Primary节点了。当然，这种是备份的目的，也可以考虑将这样的节点设置成Hidden节点</p>
</blockquote>
<p><strong>Hidden Replica Set Members</strong></p>
<blockquote>
<p>应用程序都无法访问的节点。可以用来做备份</p>
<p>Hidden Member必须是priority 0 成员节点。那样才能不成为Primary节点。（对客户端都不可见，成为Primary节点太危险,太诡异）</p>
<p>虽然Hidden节点对客户端不可见，而且不能成为Primary节点，但是当Primary节点挂掉的时候可以参与投票。</p>
</blockquote>
<p><strong>Delayed Replica Set Members</strong></p>
<blockquote>
<p>历史副本的镜像备份，具备延迟性，方便从致命性的错误中恢复回来，如：无意的删除数据库或者集合。</p>
<p>例如，当前时间 9:50，然后delayed memeber设置一小时的延迟，那么这个delayed member的数据是8:50之前的数据。</p>
<p>Delayed member必须是priority 0 memeber，这样不能成为primary节点。应该是hidden member，这样能够阻止应用程序访问delayed member。</p>
</blockquote>
<h4 id="Arbiter"><a href="#Arbiter" class="headerlink" title="Arbiter"></a>Arbiter</h4><p>一个arbiter节点不会拥有数据拷贝，也不能成为主节点。它只能在选举Primary节点的时候参与投票。而且只能投出一票。</p>
<p>如果有有偶数台机器，那么加上一台arbiter，(arbiter也就这时候用吧？) 因为arbiter member需要很少的资源，随便再加一台普通的机子即可。</p>
<blockquote>
<p><strong>IMPORTANT</strong></p>
<p>Do not run an arbiter on systems that also host the primary or the secondary members of the replica set.</p>
<p>即Arbiter节点不要和primary或者secondar节点在同一台机器上。</p>
</blockquote>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely"><a href="#Sincerely" class="headerlink" title="Sincerely!"></a>Sincerely!</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://docs.mongodb.org/manual/core/replication/" target="_blank" rel="external">http://docs.mongodb.org/manual/core/replication/</a></p>
<p>《MongoDB权威指南》</p>
]]></content>
    
    <summary type="html">
    
      MongoDB学习札记 第七篇 Replica Set 核心概念
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://webinglin.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习札记 第六篇 主从复制</title>
    <link href="http://webinglin.github.io/2015/06/08/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AF%87-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://webinglin.github.io/2015/06/08/MongoDB学习札记-第六篇-主从复制/</id>
    <published>2015-06-08T11:06:40.000Z</published>
    <updated>2016-12-17T17:55:55.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备:"></a>环境准备:</h2><ul>
<li>ubuntu12.0.4</li>
<li>mongodb3.0.3</li>
</ul>
<p>主从复制是MongoDB中最常见的复制方式。这种方式非常灵活，可用于备份，故障恢复，读扩展 等。</p>
<p>本次试验中，我们采用一个主节点，一个从节点。</p>
<a id="more"></a>
<p>首先先创建master和slave的目录</p>
<pre><code>lwb@ubuntu:~$ mkdir -p ~/mongoData/master
lwb@ubuntu:~$ mkdir -p ~/mongoData/slave
</code></pre><p>创建之后，启动master</p>
<pre><code>lwb@ubuntu:~$ mongod --master --dbpath ~/mongoData/master/ --port 10000
</code></pre><p>然后再启动slave</p>
<pre><code>lwb@ubuntu:~$ mongod --dbpath  ~/mongoData/slave/ --port 10001 --slave --source localhost:10000
</code></pre><p>接着，连接到master的机器，</p>
<pre><code>lwb@ubuntu:~$ mongo --host localhost --port 10000
</code></pre><p>往test数据库的users集合里面插入两条数据：</p>
<pre><code>&gt; db.users.find()
{ &quot;_id&quot; : ObjectId(&quot;55763d98db85929bb8addedf&quot;), &quot;username&quot; : &quot;lwb&quot; }
{ &quot;_id&quot; : ObjectId(&quot;55764a694b24187a7a3c6693&quot;), &quot;username&quot; : &quot;mongodb master-slave&quot; }
</code></pre><p>在master操作完成之后，在连接slave的mongod</p>
<pre><code>lwb@ubuntu:~$ mongo --host localhost --port 10001
MongoDB shell version: 3.0.3
connecting to: localhost:10001/test
Server has startup warnings:
2015-06-08T19:02:31.866-0700 I CONTROL  [initandlisten]
2015-06-08T19:02:31.866-0700 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/   mm/transparent_hugepage/defrag is &apos;always&apos;.
2015-06-08T19:02:31.866-0700 I CONTROL  [initandlisten] **        We suggest set   ting it to &apos;never&apos;
2015-06-08T19:02:31.866-0700 I CONTROL  [initandlisten]
&gt;
&gt; show dbs
2015-06-08T19:09:17.770-0700 E QUERY    Error: listDatabases failed:{ &quot;note&quot; : &quot;   from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }
    at Error (&lt;anonymous&gt;)
    at Mongo.getDBs (src/mongo/shell/mongo.js:47:15)
    at shellHelper.show (src/mongo/shell/utils.js:630:33)
    at shellHelper (src/mongo/shell/utils.js:524:36)
    at (shellhelp2):1:1 at src/mongo/shell/mongo.js:47
&gt;
&gt; rs.slaveOk()
&gt; 
&gt; show dbs
local  0.078GB
test   0.078GB
&gt;
&gt; use test
switched to db test
&gt; show collections
system.indexes
users
&gt;
&gt; db.users.find()
{ &quot;_id&quot; : ObjectId(&quot;55763d98db85929bb8addedf&quot;), &quot;username&quot; : &quot;lwb&quot; }
{ &quot;_id&quot; : ObjectId(&quot;55764a694b24187a7a3c6693&quot;), &quot;username&quot; : &quot;mongodb master-sla   ve&quot; }
</code></pre><h2 id="我遇到的问题及解决方法"><a href="#我遇到的问题及解决方法" class="headerlink" title="我遇到的问题及解决方法"></a>我遇到的问题及解决方法</h2><h5 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h5><blockquote>
<p>我的主从复制实验分为两次进行，刚开始我配置的master的端口是 10000 ，salve的端口是10001 ； 后因为电脑内存使用率暴涨，90+% 。 所以关掉电脑重启。问题就出现在这里，重启之后，我指定master端口的时候指定为 27000 ， 指定slave端口为 27001 所以就出现了如下问题：terminating mongod after 30 seconds</p>
</blockquote>
<pre><code>2015-06-08T18:11:37.981-0700 I NETWORK  [initandlisten] waiting for connections on port 27001
2015-06-08T18:11:38.975-0700 I REPL     [replslave] repl: --source localhost:27000 != localhost:10000 from local.sources collection
2015-06-08T18:11:38.976-0700 I REPL     [replslave] repl: for instructions on changing this slave&apos;s source, see: 2015-06-08T18:11:38.976-0700 I REPL     [replslave] http://dochub.mongodb.org/co re/masterslave
2015-06-08T18:11:38.976-0700 I REPL     [replslave] repl: terminating mongod after 30 seconds
2015-06-08T18:12:08.976-0700 I CONTROL  [replslave] dbexit:  rc: 3
</code></pre><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>如果仔细观察日志的同学应该会发现：</p>
<pre><code>2015-06-08T18:11:38.975-0700 I REPL     [replslave] repl: --source localhost:27000 != localhost:10000 from local.sources collection
</code></pre><p>所以，在一开始的时候我们已经为slave指定了master的host和port，这个会插入到local.sources 这个集合的。所以，把master端口改成10000就可以了。 </p>
<h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><blockquote>
<p>主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:    </p>
</blockquote>
<pre><code>QUERY    Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }
</code></pre><h5 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h5><p>在报错的slave机器上执行 rs.slaveOk()方法即可。</p>
<pre><code>&gt; rs.slaveOk()
&gt; show dbs
local  0.078GB
test   0.078GB
&gt; use test
switched to db test
&gt; show collections
system.indexes
users
&gt; db.users.find()
{ &quot;_id&quot; : ObjectId(&quot;55763d98db85929bb8addedf&quot;), &quot;username&quot; : &quot;lwb&quot; }
{ &quot;_id&quot; : ObjectId(&quot;55764a694b24187a7a3c6693&quot;), &quot;username&quot; : &quot;mongodb master-slave&quot; }
</code></pre><p>具体slaveOk方法是什么意思？</p>
<p><strong>rs.slaveOk()</strong></p>
<blockquote>
<p>Provides a shorthand for the following operation:</p>
<p>db.getMongo().setSlaveOk()<br>This allows the current connection to allow read operations to run on secondary members. See the readPref() method for more fine-grained control over read preference in the mongo shell.</p>
</blockquote>
<h2 id="Master-Slave安全"><a href="#Master-Slave安全" class="headerlink" title="Master-Slave安全"></a>Master-Slave安全</h2><p>这个主从安全在 <a href="http://docs.mongodb.org/manual/core/master-slave/" target="_blank" rel="external">MongoDB官网</a>说的很清楚。不能和普通的mongod权限验证那样。这里除了需要加入 –auth 还需要加入 –keyFile 的验证。</p>
<p>首先，我们生成我们的keyFile，根据官网提供的说明，这个keyfile是可以任意内容的，只要保证所有集群中的机器都拥有同样的文件即可。在linux环境下，我们通过</p>
<pre><code>openssl rand -base64 741 &gt; /usr/localhsot/mongodb/mongo-keyfile
</code></pre><p>这条命令来生成我们的keyFile。 生成之后就可以在启动mongod的时候指定了。</p>
<p>首先先启动 master</p>
<pre><code>root@ubuntu:/usr/local/mongodb# mongod --master --dbpath ~/mongoData/master/ --port 10000 --auth --keyFile /usr/local/mongodb/mongo-keyfile
</code></pre><p>这里在启动的时候可能会遇到一些问题，我是在ubuntu环境下，所以经常操作要sudo，很繁琐。因此，让当前用户获得root权限是很有必要的。</p>
<blockquote>
<p>在命令行模式执行  vi etc/passwd</p>
<p>我的用户名是 lwb ，所以将lwb所在的行改成</p>
<p>lwb:x:0:0:Ubuntu12.04,,,:/home/lwb:/bin/bash</p>
<p>原来的值是（将1000 改成 0 即可）：  lwb:x:1000:1000:Ubuntu12.04,,,:/home/lwb:/bin/bash</p>
<p>修改完成之后重启登录就可以让当前用户获得root权限了。</p>
</blockquote>
<p>回到正题，在生成mongo-keyfile后，并指定keyFile参数来启动mongod的时候，可能还会遇到另一个问题：</p>
<pre><code>root@ubuntu:~# mongod --master --dbpath ~/mongoData/master/ --port 10000 --auth --keyFile /usr/local/mongodb/mongo-keyfile
2015-06-08T21:34:43.864-0700 I ACCESS   permissions on /usr/local/mongodb/mongo-keyfile are too open
</code></pre><p>这个错误的意思是说 mongo-keyfile权限太大了，降低一下这个文件的权限。</p>
<pre><code>root@ubuntu:/usr/local/mongodb# chmod 400 mongo-keyfile
root@ubuntu:/usr/local/mongodb# ll
total 84
drwxr-xr-x  4 root root  4096 Jun  8 21:34 ./
drwxr-xr-x 11 root root  4096 Jun  8 16:49 ../
-rw-r--r--  1 root root 34520 Jun  6 07:24 GNU-AGPL-3.0
-rw-r--r--  1 root root  1359 Jun  6 07:24 README
-rw-r--r--  1 root root 22660 Jun  6 07:24 THIRD-PARTY-NOTICES
drwxr-xr-x  2 root root  4096 Jun  6 07:24 bin/
drwxr-xr-x  3 root root  4096 Jun  7 13:02 data/
-r--------  1 root root  1004 Jun  8 21:34 mongo-keyfile
</code></pre><p>重启一下mongod即可正常运行。</p>
<p>接着启动slave</p>
<pre><code>mongod --slave --dbpath ~/mongoData/slave/ --port 10001 --source localhost:10000 --auth --keyFile /usr/local/mongodb/mongo-keyfile
</code></pre><p>一切都顺利的进行着。<br>使用创建的用户操作master里面的数据库以及集合都是正常的。但是使用同样的用户操作slave的时候就有不正常了。还是提示</p>
<pre><code>QUERY    Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }
</code></pre><p>这个错误上面已经提到了。解决方法也是一样的。 rs.slaveOk() 执行完这条语句之后既可以正常操作了。</p>
<p>可以发现，用keyFile的方式启动mongod服务器其实和平常启动没什么区别，唯一的区别就是在启动参数中指定了 <code>--keyFile keyfile</code> 而已。</p>
<p>具体怎么创建用户参考: <a href="http://webinglin.github.io/2015/06/05/MongoDB%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AF%87-mongodb%E5%AE%89%E5%85%A8/">MongoDB学习札记 第二篇 mongodb安全</a></p>
<p><em>转载请注明出处！ 原文地址： <a href="http://webinglin.github.io">http://webinglin.github.io</a></em></p>
<h3 id="Sincerely！"><a href="#Sincerely！" class="headerlink" title="Sincerely！"></a>Sincerely！</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>MongoDB权威指南</p>
<p><a href="http://docs.mongodb.org/manual/core/master-slave/" target="_blank" rel="external">MongoDB官网Manual手册</a></p>
]]></content>
    
    <summary type="html">
    
      MongoDB学习札记 第六篇 主从复制
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://webinglin.github.io/tags/MongoDB/"/>
    
  </entry>
  
</feed>
